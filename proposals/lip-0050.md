```
LIP: 0050
Title: Introduce Legacy module
Author: Andreas Kendziorra <andreas.kendziorra@lightcurve.io>
        Maxime Gagnebin <maxime.gagnebin@lightcurve.io>
        Rishi Mittal <rishi.mittal@lightcurve.io>
Discussions-To: https://research.lisk.com/t/introduce-legacy-module/319
Status: Draft
Type: Standards Track
Created: 2021-08-18
Updated: 2022-02-11
Requires: 0018
```

## Abstract

The Legacy module maintains all accounts on the Lisk mainchain that received balance transfers to their address in the old 8-byte format and for which no public key is associated. The Legacy module also implements a command allowing delegates without a BLS key to register one.

In this LIP, we specify the properties of the Legacy module, along with their serialization and default values. Furthermore, we specify the commands and the functions that can be called from off-chain services.

This module is only needed for the Lisk mainchain.

## Copyright

This LIP is licensed under the [Creative Commons Zero 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).

## Motivation

Once [LIP 0018][lip-0018] is active on the Lisk mainchain, all nodes for the Lisk mainchain must maintain the accounts that received some funds before the implementation of [LIP 0018][lip-0018], but do not have an associated public key. The balance of these accounts is maintained in the legacy accounts substore and can be recovered with a reclaim transaction.

Furthermore, delegates registered before the implementation of the [Validators module][lip-0044] do not have a registered BLS key. This module implements a command to allow those delegates to register a BLS key and hence participate in the certification generation process.

Implementing the Legacy module avoids the need for other modules (specifically the Token module and the Validators module) to handle legacy behaviors present only on the Lisk mainchain. This module is only part of the Lisk mainchain, and should not be implemented in any sidechain.

## Specification

### Module ID

The Legacy module has the module ID `MODULE_ID_LEGACY` (defined in the table below).

### Notation and Constants

We define the following constants:

| Name                            | Type  | Value  | Description                                                                                                |
|---------------------------------|-------| -------|------------------------------------------------------------------------------------------------------------|
| `MODULE_ID_LEGACY`             | bytes | TBD    | Module ID of the Legacy module.                                                                            |
| `COMMAND_ID_RECLAIM`           | bytes | 0x0000 | Command ID of the reclaim command.                                                                         |
| `COMMAND_ID_REGISTER_KEYS`     | bytes | 0x0001 | Command ID of the register keys command.                                                               |
| `STORE_PREFIX_LEGACY_ACCOUNTS` | bytes | 0x0000 | Store prefix of the legacy accounts substore. This contains the addresses and balances of legacy accounts. |
| `LOCAL_ID_LSK`                 | bytes | 0x00000000 | Local identifier of the LSK token. |

### Type Definition

| Name               | Type    | Validation            | Description                     |
|--------------------|---------|-----------------------|---------------------------------|
| `PublicKeyEd25519` | bytes   | Must be of length 32. | Used for Ed25519 public keys.   |


#### Functions from Other Modules

Calling a function `fct` from another module (named `moduleName`) is represented by `moduleName.fct(required inputs)`.

### Legacy Module Store

#### Legacy Accounts Substore

This substore contains an array with the addresses and the balances of all legacy accounts for which no [reclaim transaction][lip-0018#ReclaimTransaction] was included.

##### Store Prefix, Store Key, and Store Value

* The store prefix is set to `STORE_PREFIX_LEGACY_ACCOUNTS`.
* The store key is an 8-byte value representing the legacy address.
* The store value is set to the serialization using `legacyAccountsSchema` of the balance of the legacy account.
* Notation: For the rest of this proposal, let `legacyAccounts(legacyAddress)` be the legacy accounts substore entry with store key `legacyAddress`.

##### JSON Schema

```java
legacyAccountsSchema = {
    "type": "object",
    "required": ["balance"],
    "properties": {
        "balance": {
            "dataType": "uint64",
            "fieldNumber": 1
        }
    }
}
```

##### Properties

This substore contains an entry for each legacy address for which no [reclaim transaction][lip-0018#ReclaimTransaction] was included. See also the [“Accounts without Public Key” section][lip-0018#AccountsWithoutPKey] in [LIP 0018][lip-0018].

### Internal Functions

#### Legacy Addresses

Obtaining the legacy 8-byte address from a public key.

##### Returns

The 8-byte legacy address corresponding to the given input.

##### Execution

```python
def getLegacyAddress(publicKey: PublicKeyEd25519) -> bytes:
    hashedKey = SHA-256(publicKey)
    firstEightBytes = first 8 bytes of hashedKey
    reversedEightBytes = firstEightBytes reversed
    return reversedEightBytes
```

### Events

#### AccountReclaimed

This event has `typeID = TYPE_ID_ACCOUNT_RECLAIM`.
This event is emitted when a legacy account is reclaimed.

##### Topics

* `legacyAddress`: the legacy address of the reclaimed account.
* `address`: the address of the reclaimed account.

##### Data

```java
accountReclaimedEventDataSchema = {
    "type": "object",
    "required" = ["legacyAddress", "address", "amount"],
    "properties": {
        "legacyAddress": {
            "dataType": "bytes",
            "fieldNumber": 1
        },
        "address": {
            "dataType": "bytes",
            "fieldNumber": 2
        },
        "amount": {
            "dataType": "uint64",
            "fieldNumber": 3
        },
    }
}
```

### Commands

#### Reclaim

This command allows users to reclaim tokens from a legacy account as defined in [LIP 0018][lip-0018#ReclaimTransaction]. Here, we clarify the verification and execution logic with respect to the module store.

Transactions executing this command have:

* `moduleID = MODULE_ID_LEGACY`,
* `commandID = COMMAND_ID_RECLAIM`.

##### Parameters

The `params` property of a reclaim transaction must obey the following schema:

```java
reclaimParamsSchema = {
    "type": "object",
    "required": ["amount"],
    "properties": {
        "amount": {
            "dataType": "uint64",
            "fieldNumber": 1
        }
    }
}
```

##### Verification

```python
def verify(trs: Transaction) -> None:
    legacyAddress = getLegacyAddress(trs.senderPublicKey)
    if legacyAccounts(legacyAddress) does not exists :
        raise Exception('Public key does not correspond to a reclaimable account.')

    if legacyAccounts(legacyAddress).balance != trs.params.amount:
        raise Exception('Input amount does not equal the balance of the legacy account.')
```

##### Execution

```python
def execute(trs: Transaction) -> None:
    legacyAddress = getLegacyAddress(trs.senderPublicKey)
    delete legacyAccounts(legacyAddress) from the legacy accounts substore

    newAddress = 20-byte address derived from trs.senderPublicKey
    token.mint(newAddress, LOCAL_ID_LSK, trs.params.amount)

    emitEvent(
        moduleID=MODULE_ID_LEGACY,
        typeID=TYPE_ID_ACCOUNT_RECLAIM,
        topics=[
            legacyAddress, 
            newAddress
        ],
        data={
            "legacyAddress": legacyAddress,
            "address":newAddress,
            "amount":trs.params.amount
        }
    )
```

#### Register Keys

This command allows migrated legacy validators register the required keys. In particular, this command is used by all migrated delegates to register a BLS key. This command cannot be used to modify an existing BLS key, as this is forbidden by the Validators module. Transactions executing this command have:

* `moduleID = MODULE_ID_LEGACY`,
* `commandID = COMMAND_ID_REGISTER_KEYS`.

##### Parameters

The `params` property of a register BLS key transaction must obey the following schema:

```java
registerBLSKeyParamsSchema = {
    "type": "object",
    "required": ["blsKey", "proofOfPossession", "generatorKey"],
    "properties": {
        "blsKey": {
            "dataType": "bytes",
            "fieldNumber": 1
        },
        "proofOfPossession": {
            "dataType": "bytes",
            "fieldNumber": 2
        },
        "generatorKey": {
            "dataType": "bytes",
            "fieldNumber": 3
        }
    }
}
```

#### Verification

```python
def verify(trs: Transaction) -> None:
    validatorAddress = 20-byte address derived from trs.senderPublicKey

    if validator.getValidatorAccount(validatorAddress) does not exists :
        raise Exception('Public key does not correspond to a registered validator.')
        
    validatorAccount = validator.getValidatorAccount(validatorAddress)
    if (validatorAccount.generatorKey != INVALID_ED25519_KEY
        and validatorAccount.generatorKey == trs.params.generatorKey
    ):
        raise Exception('Input generator key does not equal the one set in the store.')

    if validatorAccount.blsKey != INVALID_BLS_KEY:
        raise Exception('Validator already has a registered BLS key.')
```

##### Execution

```python
def execute(trs: Transaction) -> None:
    validatorAddress = 20-byte address derived from trs.senderPublicKey
        
    if validator.getValidatorAccount(validatorAddress).generatorKey == INVALID_ED25519_KEY:
        setGeneratorKey = validator.setValidatorGeneratorKey(validatorAddress, trs.params.generatorKey)

    # the call below will raise an exception if the proof of possession is invalid
    # with respect to the given BLS key.
    validator.setValidatorBLSKey(validatorAddress, trs.params.proofOfPossession, trs.params.blsKey)
```

### Protocol Logic for Other Modules

This module does not expose any functions.

### Endpoints for Off-Chain Services

#### getLegacyAccount

This function provides the legacy address and balance of the corresponding legacy accounts.

##### Returns

Either an object with the properties `legacyAddress` and `balance`, where `legacyAddress` is the legacy address for `publicKey` and `balance` is the balance of the corresponding legacy account, or `undefined`.

##### Execution

```python
def getLegacyAccount(publicKey: PublicKeyEd25519):
    legacyAddress = getLegacyAddress(publicKey)
    if there exists no entry in the legacy accounts substore with store key equal to legacyAddress:
        return None
    else:
        let balance be the value of the balance property of the legacy accounts substore entry with store key legacyAddress
        return {"legacyAddress": legacyAddress,
                "balance": balance}
```

### Genesis Block Processing

#### Genesis State Initialization

Let `genesisBlockAssetBytes` be the `data` bytes included in the block assets for the legacy module and let `genesisBlockAssetObject` be the deserialization of `genesisBlockAssetBytes` according to the `genesisLegacyStoreSchema` schema given below. If the deserialization fails, reject the block.

```java
genesisLegacyStoreSchema = {
    "type": "object",
    "required": ["accounts"],
    "properties": {
        "accounts": {
            "type": "array",
            "fieldNumber": 1,
            "items": {
                "type": "object",
                "required": ["address", "balance"],
                "properties": {
                    "address": {
                        "dataType": "bytes",
                        "fieldNumber": 1
                    },
                    "balance": {
                        "dataType": "uint64",
                        "fieldNumber": 2
                    }
                }
            }
        }
    }
}
```

Then, do the following:

- Check if the `address` properties of the entries in `genesisBlockAssetObject.accounts` are pairwise distinct. If not, reject the block.
- Check if the sum of the `balance` properties of the entries in `genesisBlockAssetObject.accounts` is less than 2<sup>64</sup>. If not, reject the block.
- For every `account` in `genesisBlockAssetObject.accounts`:
    - Check if `account.address` has length 8. If not, reject the block.
    - Create an entry in the legacy accounts substore with `storeKey = account.address` and `storeValue ` being the serialized value of `account.balance` according to `legacyAccountsSchema`.

## Backwards Compatibility

This LIP defines a new module and specifies its store, which in turn will become part of the state tree and will be authenticated by the state root. As such, it will induce a hardfork.

## Reference Implementation

TBA

[lip-0018]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0018.md
[lip-0018#AccountsWithoutPKey]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0018.md#accounts-without-public-key
[lip-0018#addressComputation]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0018.md#address-computation
[lip-0018#ReclaimTransaction]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0018.md#reclaim-transaction
[lip-0044]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0044.md
[lip-0044#setValidatoBLSKey]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0044.md#setvalidatorblskey
[lip-0051#mint]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0051.md#mint-1
