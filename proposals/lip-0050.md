```
LIP: 0050
Title: Introduce Legacy module
Author: Andreas Kendziorra <andreas.kendziorra@lightcurve.io>
        Maxime Gagnebin <maxime.gagnebin@lightcurve.io>
        Rishi Mittal <rishi.mittal@lightcurve.io>
Discussions-To: https://research.lisk.com/t/introduce-legacy-module/319
Status: Draft
Type: Standards Track
Created: 2021-08-18
Updated: 2022-02-11
Requires: 0018
```

## Abstract

The Legacy module maintains all accounts on the Lisk mainchain that received balance transfers to their address in the old 8-byte format and for which no public key is associated. The Legacy module also implements a command allowing delegates without a BLS key to register one.

In this LIP, we specify the properties of the Legacy module, along with their serialization and default values. Furthermore, we specify the commands and the functions that can be called from off-chain services.

This module is only needed for the Lisk mainchain.

## Copyright

This LIP is licensed under the [Creative Commons Zero 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).

## Motivation

Once [LIP 0018][lip-0018] is active on the Lisk mainchain, all nodes for the Lisk mainchain must maintain the accounts that received some funds before the implementation of [LIP 0018][lip-0018], but do not have an associated public key. The balance of these accounts is maintained in the legacy accounts substore and can be recovered with a reclaim transaction.

Furthermore, delegates registered before the implementation of the [Validators module][lip-0044] do not have a registered BLS key. This module implements a command to allow those delegates to register a BLS key and hence participate in the certification generation process. The same command is also used to allow delegates to set their generator key if it is not set yet.

Implementing the Legacy module avoids the need for other modules (specifically the Token module and the Validators module) to handle legacy behaviors present only on the Lisk mainchain. This module is only part of the Lisk mainchain, and should not be implemented in any sidechain.

## Specification

### Module ID

The Legacy module has the module ID `MODULE_ID_LEGACY` (defined in the table below).

### Notation and Constants

We define the following constants:

| Name                           | Type  | Value  | Description                                                                                                |
|--------------------------------|-------| -------|------------------------------------------------------------------------------------------------------------|
| `MODULE_ID_LEGACY`             | bytes | TBD    | Module ID of the Legacy module.                                                                            |
| `COMMAND_ID_RECLAIM`           | bytes | 0x0000 | Command ID of the reclaim command.                                                                         |
| `COMMAND_ID_REGISTER_KEYS`     | bytes | 0x0001 | Command ID of the register keys command.                                                                   |
| `TYPE_ID_ACCOUNT_RECLAIM`      | bytes | 0x0000 | The type ID of the account reclaim event.                                                                  |
| `TYPE_ID_KEYS_REGISTERED`      | bytes | 0x0001 | The type ID of the keys registered event.                                                                  |
| `STORE_PREFIX_LEGACY_ACCOUNTS` | bytes | 0x0000 | Store prefix of the legacy accounts substore. This contains the addresses and balances of legacy accounts. |
| `LOCAL_ID_LSK`                 | bytes | 0x00000000 | Local identifier of the LSK token.                                                                     |
| `TOKEN_ID_LSK_MAINCHAIN`       | bytes | 8 bytes all set to `0`  | Identifier of the LSK token on the Lisk mainchain.                                        |
| `INVALID_BLS_KEY`              | bytes | 48 bytes all set to `0` | The BLS public key set during the migration for validators without a BLS key.             |
| `INVALID_ED25519_KEY`          | bytes | 32 bytes all set to `255` | The Ed25519 public key set during the migration for validators without a generator key. |
| `ADDRESS_LEGACY_RESERVE`       | bytes | `SHA-256(b'legacyReserve')[:20]` | The address used to store all tokens of legacy accounts.                         |

### Type Definition

| Name               | Type    | Validation            | Description                     |
|--------------------|---------|-----------------------|---------------------------------|
| `PublicKeyEd25519` | bytes   | Must be of length 32. | Used for Ed25519 public keys.   |


#### Functions from Other Modules

Calling a function `fct` from another module (named `moduleName`) is represented by `moduleName.fct(required inputs)`.

### Legacy Module Store

#### Legacy Accounts Substore

This substore contains an array with the addresses and the balances of all legacy accounts for which no [reclaim transaction][lip-0018#ReclaimTransaction] was included.

##### Store Prefix, Store Key, and Store Value

* The store prefix is set to `STORE_PREFIX_LEGACY_ACCOUNTS`.
* The store key is an 8-byte value representing the legacy address.
* The store value is set to the serialization using `legacyAccountsSchema` of the balance of the legacy account.
* Notation: For the rest of this proposal, let `legacyAccounts(legacyAddress)` be the legacy accounts substore entry with store key `legacyAddress`.

##### JSON Schema

```java
legacyAccountsSchema = {
    "type": "object",
    "required": ["balance"],
    "properties": {
        "balance": {
            "dataType": "uint64",
            "fieldNumber": 1
        }
    }
}
```

##### Properties

This substore contains an entry for each legacy address for which no [reclaim transaction][lip-0018#ReclaimTransaction] was included. See also the [“Accounts without Public Key” section][lip-0018#AccountsWithoutPKey] in [LIP 0018][lip-0018].

### Internal Functions

#### Legacy Addresses

Obtaining the legacy 8-byte address from a public key.

##### Returns

The 8-byte legacy address corresponding to the given input.

##### Execution

```python
def getLegacyAddress(publicKey: PublicKeyEd25519) -> bytes:
    hashedKey = SHA-256(publicKey)
    firstEightBytes = first 8 bytes of hashedKey
    reversedEightBytes = firstEightBytes reversed
    return reversedEightBytes
```

### Events

#### AccountReclaimed

This event has `typeID = TYPE_ID_ACCOUNT_RECLAIM`.
This event is emitted when a legacy account is reclaimed.

##### Topics

* `legacyAddress`: the legacy address of the reclaimed account.
* `address`: the address of the reclaimed account.

##### Data

```java
accountReclaimedEventDataSchema = {
    "type": "object",
    "required" = ["legacyAddress", "address", "amount"],
    "properties": {
        "legacyAddress": {
            "dataType": "bytes",
            "length": 8,
            "fieldNumber": 1
        },
        "address": {
            "dataType": "bytes",
            "length": 20,
            "fieldNumber": 2
        },
        "amount": {
            "dataType": "uint64",
            "fieldNumber": 3
        },
    }
}
```

#### KeysRegistered

This event has `typeID = TYPE_ID_KEYS_REGISTERED`.
This event is emitted when a legacy account is reclaimed.

##### Topics

* `address`: the address sending the command.
* `generatorKey`: the registered generator key.
* `blsKey`: the registered BLS key.

##### Data

```java
keysRegisteredEventDataSchema = {
    "type": "object",
    "required" = ["address", "generatorKey", "blsKey"],
    "properties": {
        "address": {
            "dataType": "bytes",
            "length": 20,
            "fieldNumber": 1
        },
        "generatorKey": {
            "dataType": "bytes",
            "length": 32,
            "fieldNumber": 2
        },
        "blsKey": {
            "dataType": "bytes",
            "length": 48,
            "fieldNumber": 3
        },
    }
}
```

### Commands

#### Reclaim

This command allows users to reclaim tokens from a legacy account as defined in [LIP 0018][lip-0018#ReclaimTransaction]. Here, we clarify the verification and execution logic with respect to the module store.

Transactions executing this command have:

* `moduleID = MODULE_ID_LEGACY`,
* `commandID = COMMAND_ID_RECLAIM`.

##### Parameters

The `params` property of a reclaim transaction must obey the following schema:

```java
reclaimParamsSchema = {
    "type": "object",
    "required": ["amount"],
    "properties": {
        "amount": {
            "dataType": "uint64",
            "fieldNumber": 1
        }
    }
}
```

##### Verification

```python
def verify(trs: Transaction) -> None:
    legacyAddress = getLegacyAddress(trs.senderPublicKey)
    if legacyAccounts(legacyAddress) does not exists :
        raise Exception('Public key does not correspond to a reclaimable account.')

    if legacyAccounts(legacyAddress).balance != trs.params.amount:
        raise Exception('Input amount does not equal the balance of the legacy account.')
```

##### Execution

```python
def execute(trs: Transaction) -> None:
    legacyAddress = getLegacyAddress(trs.senderPublicKey)
    delete legacyAccounts(legacyAddress) from the legacy accounts substore

    newAddress = 20-byte address derived from trs.senderPublicKey
    # Unlock the tokens in the legacy reserve account and transfer them to the 
    # account reclaiming the tokens.
    token.unlock(ADDRESS_LEGACY_RESERVE, MODULE_ID_LEGACY, TOKEN_ID_LSK_MAINCHAIN, trs.params.amount)

    token.transfer(ADDRESS_LEGACY_RESERVE, newAddress, TOKEN_ID_LSK_MAINCHAIN, trs.params.amount)

    emitEvent(
        moduleID=MODULE_ID_LEGACY,
        typeID=TYPE_ID_ACCOUNT_RECLAIM,
        data=serialize(
            {
                "legacyAddress": legacyAddress,
                "address":newAddress,
                "amount":trs.params.amount
            }, 
            accountReclaimedEventDataSchema
        ),
        topics=[
            legacyAddress, 
            newAddress
        ]
    )
```

#### Register Keys

This command allows migrated legacy validators register the required keys. In particular, this command is used by all migrated delegates to register a BLS key. This command cannot be used to modify an existing BLS key, as this is forbidden by the Validators module. Transactions executing this command have:

* `moduleID = MODULE_ID_LEGACY`,
* `commandID = COMMAND_ID_REGISTER_KEYS`.

##### Parameters

The `params` property of a register BLS key transaction must obey the following schema:

```java
registerBLSKeyParamsSchema = {
    "type": "object",
    "required": ["blsKey", "proofOfPossession", "generatorKey"],
    "properties": {
        "blsKey": {
            "dataType": "bytes",
            "length": 48,
            "fieldNumber": 1
        },
        "proofOfPossession": {
            "dataType": "bytes",
            "length": 96,
            "fieldNumber": 2
        },
        "generatorKey": {
            "dataType": "bytes",
            "length": 32,
            "fieldNumber": 3
        }
    }
}
```

#### Verification

```python
def verify(trs: Transaction) -> None:

    validatorAddress = 20-byte address derived from trs.senderPublicKey

    if validator.getValidatorAccount(validatorAddress) does not exists :
        raise Exception('Public key does not correspond to a registered validator.')

    if validatorAccount.blsKey != INVALID_BLS_KEY:
        raise Exception('Validator already has a registered keys.')
```

##### Execution

```python
def execute(trs: Transaction) -> None:
    validatorAddress = 20-byte address derived from trs.senderPublicKey

    validator.setValidatorGeneratorKey(validatorAddress, trs.params.generatorKey)

    # the calls below will raise an exception if the proof of possession is invalid
    # with respect to the given BLS key.
    validator.setValidatorBLSKey(validatorAddress, trs.params.proofOfPossession, trs.params.blsKey)
    emitEvent(
        moduleID=MODULE_ID_LEGACY,
        typeID=TYPE_ID_KEYS_REGISTERED,
        data=serialize(
            {
                "address": validatorAddress,
                "generatorKey": trs.params.generatorKey,
                "blsKey": trs.params.blsKey
            }, 
            keysRegisteredEventDataSchema
        ),
        topics=[
            validatorAddress, 
            trs.params.generatorKey,
            trs.params.blsKey
        ]
    )
```

### Protocol Logic for Other Modules

This module does not expose any functions.

### Endpoints for Off-Chain Services

#### getLegacyAccount

This function provides the legacy address and balance of the corresponding legacy accounts.

##### Returns

An object with the properties `legacyAddress` and `balance`, where `legacyAddress` is the legacy address for `publicKey` and `balance` is the balance of the corresponding legacy account, or with `0` balance if the account is not available for reclaim.

##### Execution

```python
def getLegacyAccount(publicKey: PublicKeyEd25519) -> dict:
    legacyAddress = getLegacyAddress(publicKey)
    if there exists no entry in the legacy accounts substore with store key equal to legacyAddress:
        return {"legacyAddress": legacyAddress,
                "balance": 0}
    else:
        let balance be the value of the balance property of the legacy accounts substore entry with store key legacyAddress
        return {"legacyAddress": legacyAddress,
                "balance": balance}
```

### Genesis Block Processing

#### Genesis State Initialization

Let `genesisBlockAssetBytes` be the `data` bytes included in the block assets for the legacy module and let `genesisBlockAssetObject` be the deserialization of `genesisBlockAssetBytes` according to the `genesisLegacyStoreSchema` schema given below. If the deserialization fails, reject the block.

```java
genesisLegacyStoreSchema = {
    "type": "object",
    "required": ["accounts"],
    "properties": {
        "accounts": {
            "type": "array",
            "fieldNumber": 1,
            "items": {
                "type": "object",
                "required": ["address", "balance"],
                "properties": {
                    "address": {
                        "dataType": "bytes",
                        "length": 8,
                        "fieldNumber": 1
                    },
                    "balance": {
                        "dataType": "uint64",
                        "fieldNumber": 2
                    }
                }
            }
        }
    }
}
```

Then, do the following:

- Check if the `address` properties of the entries in `genesisBlockAssetObject.accounts` are pairwise distinct. If not, reject the block.
- Check if the sum of the `balance` properties of the entries in `genesisBlockAssetObject.accounts` is less than 2<sup>64</sup>. If not, reject the block.
- Check if the sum of the `balance` properties of the entries in `genesisBlockAssetObject.accounts` equals `token.getLockedAmount(ADDRESS_LEGACY_RESERVE, MODULE_ID_LEGACY, TOKEN_ID_LSK_MAINCHAIN)`.
- For every `account` in `genesisBlockAssetObject.accounts`:
    - Create an entry in the legacy accounts substore with `storeKey = account.address` and `storeValue ` being the serialized value of `account.balance` according to `legacyAccountsSchema`.

## Backwards Compatibility

This LIP defines a new module and specifies its store, which in turn will become part of the state tree and will be authenticated by the state root. As such, it will induce a hardfork.

## Reference Implementation

TBA

[lip-0018]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0018.md
[lip-0018#AccountsWithoutPKey]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0018.md#accounts-without-public-key
[lip-0018#addressComputation]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0018.md#address-computation
[lip-0018#ReclaimTransaction]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0018.md#reclaim-transaction
[lip-0044]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0044.md
[lip-0044#setValidatoBLSKey]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0044.md#setvalidatorblskey
[lip-0051#mint]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0051.md#mint-1
