```
LIP: 0053
Title: Introduce cross-chain update mechanism
Author: Maxime Gagnebin <maxime.gagnebin@lightcurve.io>
Discussions-To: https://research.lisk.com/t/introduce-cross-chain-update-mechanism/298
Status: Draft
Type: Standards Track
Created: 2021-05-22
Updated: 2022-03-22
Requires: 0045, 0049, 0058, 0061
```

## Abstract

This LIP introduces _cross-chain update transactions_ which are used to post certified information and cross-chain messages in Lisk ecosystem chains.

Cross-chain update transactions are the carriers of the information transmitted between chains. By posting a cross-chain update, the receiving chain gets the information required about the advancement of the sending chain. The transaction can also include cross-chain messages and thus serves as an envelope for messages from one chain to another.

## Copyright

This LIP is licensed under the [Creative Commons Zero 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).

## Motivation

Motivation for the Lisk Interoperability module and the cross-chain update transaction can be found in [LIP 0045][lip-0045].

## Rationale

### Cross-chain Update Transaction Properties

#### sendingChainId

Identifies the chain sending the cross-chain update. Only cross-chain update transactions coming from [registered][lip-0043] chains are valid, registered chains are the ones with an entry in the interoperability store corresponding to their `chainID`.

#### certificate

Used to update the cross-chain account. It must be a certificate with an adequate [BLS signature][lip-0038]. The signature is always validated against the public key set stored in the sending chain account.

It is important to note here that the validation of this signature is done with respect to the network identifier of the sending chain. This network identifier is included in the sending chain account in the interoperability store.

#### activeValidatorsUpdate

The chain account stores an array containing the BLS keys and BFT weights required to validate the certificate signature. This array has to be updated if the validator set changes in the chain sending the certificate. The difference between the stored array and the new one is included in this property.

#### newCertificateThreshold

The chain account stores the threshold required to validate the certificate signature. This certificate threshold has to be updated if its value changes in the chain sending the certificate. In that case, the updated value is set in the `newCertificateThreshold` property of the CCU. If `newCertificateThreshold` is set to `0`, it implies that the certificate threshold has not been changed in the sending chain.

#### inboxUpdate

The `inboxUpdate` contains the information relative to the messages to be included in the sending chain inbox. As specified in [LIP 0045][lip-0045], cross-chain messages are stored in the chain outbox on the sending chain and in the corresponding inbox on the receiving chain. This property contains three elements: the cross-chain messages themselves, an inclusion witness into the outbox root, and an inclusion witness of this outbox root into the state root.

##### crossChainMessages

An array of cross-chain messages. See [LIP 0049][lip-0049] for the general properties and processing of cross-chain messages. The `crossChainMessages` property must contain consecutive messages from the outbox.

##### messageWitnessHashes

In the sending chain, all cross-chain messages are added to a regular Merkle tree attested by the outbox root. The `messageWitnessHashes` are the sibling hashes necessary for the Merkle proof.

This Merkle proof is required if not all messages necessary to recompute the outbox root were given in `crossChainMessages`. If all messages required to compute the outbox root are included in `crossChainMessages` then `siblingHashes` can be left empty.

##### outboxRootWitness

The outbox root of the sending chain is part of a sparse Merkle tree attested by the state root (provided in the certificate). The `outboxRootWitness` property is an inclusion proof into the state root of the outbox root computed from the receiving chain inbox, `crossChainMessages` and `messageWitnessHashes`. If the cross-chain update transaction contains an empty certificate, this property can also be left empty, as the required root was already attested in a previous cross-chain update.

### Posting Cross-chain Updates on Mainchain and on Sidechains

As the roles of both mainchain and sidechain are quite different, so are the transactions used to post cross-chain updates. The most notable differences are:

* On the mainchain, all CCMs included in the `inboxUpdate` must have their `sendingChainID` equal to the chainID sending the cross-chain update.
* On sidechains, all CCMs included in the `inboxUpdate` must have their `receivingChainID` equal to the chainID of the sidechain receiving the cross-chain update (if has the default "ok" status).
* As the mainchain accepts CCMs with `receivingChainID` corresponding to another sidechain, the cross-chain update processing on the mainchain is responsible for the inclusion of those CCMs in the corresponding outbox.

These points guarantee that the CCMs are always forwarded to the correct chains and that the receiving chain can be confident that the chain specified in `ccm.sendingChainID` was truly the chain issuing the CCM.

### Creating and Posting Cross-chain Update Transactions

The Lisk consensus mechanism is designed to create and publish certificates regularly. In that regard, obtaining the information required to post a cross-chain update transaction is easy and straightforward. The following is an example workflow that a relayer for a given sidechain could follow.

Setup to gather the required mainchain information:

* Run a mainchain node.
* Maintain a list of all CCMs included in the sidechain outbox. For each height where a CCM was included in the outbox, also save the inclusion witness of the outbox into the state root. All CCMs and witnesses for heights that have been certified on the sidechain can be discarded.
* Maintain a history of all validator changes on the mainchain for rounds that have not yet been certified on the sidechain.

Create a cross-chain update transaction for a given height `h1`:

* Find a [signed certificate][lip-0061] in the mainchain block headers for a height (say `h2`) higher or equal to `h1`. This will be used as the `certificate` property of the transaction.
* The property `inboxUpdate.crossChainMessages` lists all CCMs that have been included in the sidechain outbox up to `h2` (and which have not been included on the sidechain yet). In this case, the `messageWitnessHashes` will be empty.
* Compute the inclusion proof for the outbox root of the sidechain account into the mainchain state root. This proof is then used to compute `inboxUpdate.outboxRootWitness`.
* Compute the required update to the active validators stored in the chain account and the validators that were used to create `certificate.validatorsHash`. This update can be obtained by following the logic of `getActiveValidatorsDiff` as detailed in the [Appendix](#appendix).
* If the `certificateThreshold` used to create `certificate.validatorsHash` is different from the one stored in the chain account, include the new value in the `newCertificateThreshold` property.
* Post the cross-chain update transaction on the sidechain.

Relayers should post cross-chain update transactions on the sidechain when the need for it arises. This can be either because some CCMs have been included in the outbox and need to be relayed, or when the mainchain validators changes require the channel to be updated on the sidechain.

The role of relayer is totally symmetric for relaying information from a sidechain to the mainchain.

#### Posting Partial Cross-chain Updates

The Lisk protocol allows relayers to post cross-chain update transactions which do not contain all CCMs, as opposed to the mechanism explained in the previous section. This can be useful for example when the list of CCMs is too large to be included in a single block.

The cross-chain update transaction can contain an `inboxUpdate` which does not contain all CCMs required to recompute the outbox root corresponding to the given state root. In that case, the relayer has to make sure that an appropriate `messageWitnessHashes` is provided. This witness is constructed as a right witness as defined in [LIP 0031](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0031.md).

If a cross-chain update was submitted without all the CCMs (as explained in the previous paragraph), then it is possible to provide those missing CCMs without the need to provide another `certificate` or `outboxRootWitness` (technically an empty `certificate` and `outboxRootWitness` are provided). The cross-chain update transaction contains only the missing CCMs and the potential `messageWitnessHashes`.

Those options for partial cross-chain update transactions are not expected to be used regularly. It is however a good option in corner case events where the sidechain outbox suddenly becomes very large.

#### Malicious Cross-chain Update Transactions

A cross-chain update transaction may have been created with validly signed information according to the [validity rules](#parameters-validity) and hence be included in the blockchain. However, the transaction could include invalid CCMs. Those will be detected when trying to process the `inboxUpdate`.

If a CCM is invalid (as specified in the ["Execute Cross-chain Updates" section](#execute-cross-chain-updates)), then the sending chain is [terminated][lip-0045#termination].
The CCU processing then continues and CCMs from other chains are applied.
All CCMs from terminated chains have no effect, they are neither applied nor forwarded.

#### First Cross-chain Update from a Sidechain

The first cross-chain update containing messages from a given chain has a special function. It will change the sending chain status from `CHAIN_REGISTERED` to `CHAIN_ACTIVE`. This change means that the receiving chain is now available to receive cross-chain messages and can interact with the sending chain. Additionally, once active, sidechains must follow the liveness condition and regularly post cross-chain updates on the mainchain (at least once every 30 days). If the sidechain fails to follow the liveness condition, it is terminated on the mainchain.

When a sidechain is started and registered, the sidechain developers might decide to not activate the sidechain straight away (maybe to do further testing). It could happen then (intentionally or not) that an old block header (almost 30 days old) is submitted to the mainchain to activate the sidechain. This could result in the sidechain being terminated for liveness failure very soon after the activation (maybe only a few minutes later). To prevent this issue (and without any significant drawbacks) the first cross-chain update to be submitted on mainchain must contain a certificate less that 15 days old. The sidechain has therefore at least 15 days to submit the next cross-chain update to the mainchain and start the regular posting of cross-chain updates.

## Specification

The Interoperability module supports two commands used to certify the state of another chain. Those commands have `moduleID = MODULE_ID_INTEROPERABILITY`. The mainchain cross-chain update, meant to be posted on the mainchain, has `commandID = COMMAND_ID_MAINCHAIN_CCU`, while the sidechain cross-chain update, meant to be posted on sidechains, has `commandID = COMMAND_ID_SIDECHAIN_CCU`.

### Constants and Notations

The following constants are used throughout the document:

| Name                                                     | Type   | Value                   |
|----------------------------------------------------------|--------|-------------------------|
| **Interoperability Constants**                           |        |                         |
| `MODULE_ID_INTEROPERABILITY`                             | bytes  | TBD                     |
| `STORE_PREFIX_CHAIN_DATA`                                | bytes  | 0x8000                  |
| `LIVENESS_LIMIT`                                         | uint32 | `30*24*3600`            |
| **Interoperability Command and Cross-chain Command IDs** |        |                         |
| `COMMAND_ID_SIDECHAIN_CCU`                               | bytes  | 0x0002                  |
| `COMMAND_ID_MAINCHAIN_CCU`                               | bytes  | 0x0003                  |
| **Chain Status**                                         |        |                         |
| `CHAIN_REGISTERED`                                       | uint32 | 0                       |
| `CHAIN_ACTIVE`                                           | uint32 | 1                       |  
| `CHAIN_TERMINATED`                                       | uint32 | 2                       |
| **Message Tags**                                         |        |                         |
| `MESSAGE_TAG_CERTIFICATE `                               | bytes  | "LSK_CE_" ASCII-encoded |

Several of those constants are shared with the other LIPs defining the Interoperability module and all of the needed constants for the Interoperability module are defined in [LIP 0045][lip-0045]. That LIP should be considered correct if a value stated here differs.

### Type Definition

| Name               | Type    | Validation            | Description                     |
|--------------------|---------|-----------------------|---------------------------------|
| `Address` | bytes   | Must be of length `ADDRESS_LENGTH`. | Address of an account.   |
| `ModuleID` | bytes   | Must be of length `MODULE_ID_LENGTH`. | ID of a module.   |
| `CrossChainCommandID` | bytes   | Must be of length `CROSS_CHAIN_COMMAND_ID_LENGTH`. | ID of a cross-chain command.   |
| `ChainID` | bytes   | Must be of length `CHAIN_ID_LENGTH`. | ID of a chain.   |
| `CCM` | dict   | Must follow the `crossChainMessageSchema` schema. | The type of cross-chain messages.   |
| `MerkleRoot` | bytes   | Must be of length `MERKLE_ROOT_LENGTH`. | The root of a Merkle tree.   |
| `PublicKeyEd25519` | bytes | Must be of length `ED25519_PUBLIC_KEY_LENGTH`. | Used for Ed25519 public keys. |
| `PublicKeyBLS` | bytes | Must be of length `BLS_PUBLIC_KEY_LENGTH`. | Used for BLS keys. |
| `ActiveValidator` | object | Must have `blsKey: PublicKeyBLS` and `bftWeight: uint64` properties. | The BLS key and BFT weight of an active validator. |


### Commands

#### MainchainCrossChainUpdate

This command is used to submit a cross-chain update on the mainchain.

Transactions executing this command have:

* `moduleID = MODULE_ID_INTEROPERABILITY`,
* `commandID = COMMAND_ID_MAINCHAIN_CCU`.


##### Parameters

```java
crossChainUpdateTransactionParams = {
    "type": "object",
    "required": [
        "sendingChainID",
        "certificate",
        "activeValidatorsUpdate",
        "newCertificateThreshold",
        "inboxUpdate"
    ],
    "properties": {
        "sendingChainID": {
            "dataType": "bytes",
            "length": CHAIN_ID_LENGTH,
            "fieldNumber": 1
        },
        "certificate": {
            "dataType": "bytes",
            "fieldNumber": 2
        },
        "activeValidatorsUpdate": {
            "type": "array",
            "fieldNumber": 3,
            "items": {
                "type": "object",
                "required": [
                    "blsKey",
                    "bftWeight"
                ],
                "properties": {
                    "blsKey": {
                        "dataType": "bytes",
                        "length": PUBLIC_KEY_BLS_LENGTH,
                        "fieldNumber": 1
                    },
                    "bftWeight": {
                        "dataType": "uint64",
                        "fieldNumber": 2
                    }
                }
            }
        },
        "newCertificateThreshold": {
            "dataType": "uint64",
            "fieldNumber": 4
        },
        "inboxUpdate": {
            "type": "object",
            "fieldNumber": 5,
            "required": [
                "crossChainMessages",
                "messageWitnessHashes",
                "outboxRootWitness"
            ],
            "properties": {
                "crossChainMessages": {
                    "type": "array",
                    "fieldNumber": 1,
                    "items": {"dataType": "bytes"}
                },
                "messageWitnessHashes": {
                    "type": "array",
                    "fieldNumber": 2,
                    "items": {
                        "dataType": "bytes",
                        "length": HASH_LENGTH
                    }
                },
                "outboxRootWitness": {
                    "type": "object",
                    "fieldNumber": 3,
                    "required": ["bitmap", "siblingHashes"],
                    "properties": {
                        "bitmap": {
                            "dataType": "bytes",
                            "fieldNumber": 1
                        },
                        "siblingHashes": {
                            "type": "array",
                            "fieldNumber": 2,
                            "items": {
                                "dataType": "bytes",
                                "length": HASH_LENGTH
                            }
                        }
                    }
                }
            }
        }
    }
}
```

##### Verification

```python
def verify(trs: Transaction) -> None:
    # Liveness condition is only checked on the mainchain.
    verifyLivenessCondition(trs)
    verifyCertificate(trs)
    verifyValidatorsUpdate(trs)
    verifyInboxUpdate(trs)
```

##### Execution

```python
def execute(trs: Transaction) -> None:
    inboxUpdate = trs.params.inboxUpdate
    if len(inboxUpdate.crossChainMessages) > 0:
        sidechainID = trs.params.sendingChainID
        sidechainAccount = chainAccount(sidechainID)
        if sidechainAccount.status == CHAIN_REGISTERED:
            firstCCMBytes = inboxUpdate.crossChainMessages[0]
            ccm = decode(crossChainMessageSchema, firstCCMBytes)
            if ccm.crossChainCommandID == CROSS_CHAIN_COMMAND_ID_REGISTRATION and ccm.receivingChainID == MAINCHAIN_ID:
                sidechainAccount.status == CHAIN_ACTIVE
            else:
                terminateChainInternal(sidechainID)
                return
        
        for ccmBytes in inboxUpdate.crossChainMessages:
            ccm = decode(crossChainMessageSchema, ccmBytes)

            # Perform basic checks. If they fail, terminate sending chain.
            try:
                validateFormat(ccm)
            except:
                terminateChainInternal(sidechainID)
                return
            if sidechainID != ccm.sendingChainID:
                terminateChainInternal(sidechainID)
                return
            
            # Process the ccm.
            if ccm.receivingChainID == MAINCHAIN_ID:
                # The Token module is called to transfer the fee to the ccu sender
                try:
                    senderAddress = Address derived from ccu.senderPublicKey
                    token.assignMessageFee(senderAddress, ccm)
                except:
                    terminateChainInternal(sidechainID)
                    return
                apply(ccu, ccm)
            elif ccm.receivingChainID != MAINCHAIN_ID:
                # The Token module is called to transfer the fee from sending to receiving chain
                try: 
                    token.forwardMessageFee(ccm)
                except:
                    terminateChainInternal(sidechainID)
                    return
                forward(ccu, ccm)

            appendToInboxTree(sidechainID, ccmBytes)
    
    # Update sidechain validators.
    if ccu.params.newCertificateThreshold > 0:
        validators(sidechainID).certificateThreshold = ccu.params.newCertificateThreshold
    else:
        validators(sidechainID).certificateThreshold = validators(sidechainID).certificateThreshold

    validators(sidechainID).activeValidators = updateActiveValidators(
        validators(sidechainID).activeValidators, 
        trs.params.activeValidatorsUpdate
    )

    # Update last certificate.
    certificateBytes = ccu.params.certificate
    if len(certificateBytes) > 0:
        certificate = decode(certificateSchema, certificateBytes)
        sidechainAccount.lastCertificate = {
            "height": certificate.height,
            "timestamp": certificate.timestamp, 
            "stateRoot": certificate.stateRoot, 
            "validatorsHash": certificate.validatorsHash
        }
    
    # Update partnerChainOutboxRoot.
    messageWitnessHashes = ccu.params.inboxUpdate.messageWitnessHashes
    inbox = channel(sidechainID).inbox
    if len(messageWitnessHashes) > 0:
        # calculateRootFromRightWitness is specified in LIP 0031.
        channel(sidechainID).partnerChainOutboxRoot = calculateRootFromRightWitness(inbox.size, inbox.appendPath, messageWitnessHashes)
    else:
        channel(sidechainID).partnerChainOutboxRoot = inbox.root
```

#### SidechainCrossChainUpdate

This command is used to submit a cross-chain update on a sidechain.

Transactions executing this command have:

* `moduleID = MODULE_ID_INTEROPERABILITY`,
* `commandID = COMMAND_ID_SIDECHAIN_CCU`.

##### Parameters

This command uses the same `crossChainUpdateTransactionParams` schema as the `MainchainCrossChainUpdate` command.

##### Verification

```python
def verify(trs: Transaction) -> None:
    verifyCertificate(trs)
    verifyValidatorsUpdate(trs)
    verifyInboxUpdate(trs)
```

##### Execution

```python
def execute(trs: Transaction) -> None:
    inboxUpdate = trs.params.inboxUpdate
    if len(inboxUpdate.crossChainMessages) > 0:
        mainchainID = trs.params.sendingChainID
        mainchainAccount = chainAccount(mainchainID)
        if mainchainAccount.status == CHAIN_REGISTERED:
            firstCCMBytes = inboxUpdate.crossChainMessages[0]
            ccm = decode(crossChainMessageSchema, firstCCMBytes)
            if ccm.crossChainCommandID == CROSS_CHAIN_COMMAND_ID_REGISTRATION and ccm.sendingChainID == mainchainID:
                mainchainAccount.status == CHAIN_ACTIVE
            else:
                terminateChainInternal(mainchainID)
                return
        
        for ccmBytes in inboxUpdate.crossChainMessages:
            ccm = decode(crossChainMessageSchema, ccmBytes)

            # Perform basic checks. If they fail, terminate sending chain.
            try:
                validateFormat(ccm)
            except:
                terminateChainInternal(mainchainID)
                return
            if ownChainAccount.ID != ccm.receivingChainID and ccm.status == CCM_STATUS_OK:
                terminateChainInternal(mainchainID)
                return
            
            # Process the ccm.
            # The Token module is called to transfer the fee to the ccu sender
            # Notice that on a sidechain, this function should not fail.
            senderAddress = Address derived from ccu.senderPublicKey
            token.assignMessageFee(senderAddress, ccm)
            
            apply(ccu, ccm)
            appendToInboxTree(sidechainID, ccmBytes)
    
    # Update mainchain validators.
    if ccu.params.newCertificateThreshold > 0:
        validators(mainchainID).certificateThreshold = ccu.params.newCertificateThreshold
    else:
        validators(mainchainID).certificateThreshold = validators(mainchainID).certificateThreshold

    validators(mainchainID).activeValidators = updateActiveValidators(
        validators(mainchainID).activeValidators, 
        trs.params.activeValidatorsUpdate
    )

    # Update last certificate.
    certificateBytes = ccu.params.certificate
    if len(certificateBytes) > 0:
        certificate = decode(certificateSchema, certificateBytes)
        mainchainAccount.lastCertificate = {
            "height": certificate.height,
            "timestamp": certificate.timestamp, 
            "stateRoot": certificate.stateRoot, 
            "validatorsHash": certificate.validatorsHash
        }
    
    # Update partnerChainOutboxRoot.
    messageWitnessHashes = ccu.params.inboxUpdate.messageWitnessHashes
    inbox = channel(mainchainID).inbox
    if len(messageWitnessHashes) > 0:
        # calculateRootFromRightWitness is specified in LIP 0031.
        channel(mainchainID).partnerChainOutboxRoot = calculateRootFromRightWitness(inbox.size, inbox.appendPath, messageWitnessHashes)
    else:
        channel(mainchainID).partnerChainOutboxRoot = inbox.root
```

### Internal Functions

The following functions are used internally by the Interoperability module to verify and execute cross-chain updates.

#### Liveness of Sidechains

A mainchain CCU command is only valid if the sidechain is not terminated and follows the [liveness rule][lip-0045#livenessCondition]. 

There are extra requirements for the first CCU posted on the mainchain.
It must contain a non-empty `certificate` which follows the schema defined in [LIP 0061][lip-0061#certificate-schema].
Furthermore, if this first CCU also contains a non-empty `inboxUpdate`, the certificate is only valid if it allows the sidechain account to remain live for a reasonable amount of time.

```python
def verifyLivenessCondition(ccu: CCU) -> None:
    sidechainID = ccu.params.sendingChainID

    if chainAccount(sidechainID).status == CHAIN_REGISTERED:
        certificateBytes = ccu.params.certificate
        if len(certificateBytes) == 0:
            raise Exception("The first mainchain CCU must contain a non-empty certificate.")
        
        certificate = decode(certificateSchema, certificateBytes)
        timestamp = timestamp of the block including ccu
        if len(ccu.params.inboxUpdate) > 0 and timestamp - certificate.timestamp > LIVENESS_LIMIT / 2:
            raise Exception(f"First certificate cannot be older than {LIVENESS_LIMIT / 2}.")

    if chainAccount(sidechainID).status == CHAIN_TERMINATED:
        raise Exception("Sidechain is terminated.")

    if not isLive(sidechainID):
        raise Exception("Sidechain is not live.")
``` 

#### Certificate Validity

```python
def verifyCertificate(ccu: CCU) -> None:
    certificateBytes = ccu.params.certificate
    if len(certificateBytes) == 0:
        return

    certificate = decode(certificateSchema, certificateBytes)
    partnerchainID = ccu.params.sendingChainID
    partnerchainAccount = chainAccount(partnerchainID)
    # Certificate height must be greater than last certificate height.
    if certificate.height <= partnerchainAccount.lastCertificate.height:
        raise Exception("Certificate height is not greater than last certificate height.")
    # Certificate timestamp must be smaller than timestamp of the block including the ccu.
    timestamp = timestamp of the block including ccu
    if certificate.timestamp >= timestamp:
        raise Exception("Certificate timestamp is not smaller than timestamp of the block including the ccu.")

    # Certificate signature must be a valid aggregate signature for the sdechain validators.
    # verifyAggregateCertificateSignature is defined in LIP 0061.
    validatorKeys = [validator["blsKey"] for validator in validators(partnerchainID).activeValidators]
    validatorWeights = [validator["bftWeight"] for validator in validators(partnerchainID).activeValidators]
    verifyAggregateCertificateSignature(
        validatorKeys, 
        validatorWeights, 
        validators(partnerchainID).certificateThreshold, 
        partnerchainAccount.networkID, 
        certificate)
```

#### Validators Update Validity

```python
def verifyValidatorsUpdate(ccu: CCU) -> None:
    if len(ccu.params.activeValidatorsUpdate) == 0 and ccu.params.newCertificateThreshold == 0:
        return

    certificateBytes = ccu.params.certificate
    if len(certificateBytes) == 0:
        raise Exception("Certificate must be non-empty if validators or certicate threshold have been updated.")
    
    partnerchainID = ccu.params.sendingChainID
    validatorKeys = [validator["blsKey"] for validator in validators(partnerchainID).activeValidators]
    # All validator keys must be valid BLS keys.
    for key in validatorKeys:
        if len(key) != PUBLIC_KEY_BLS_LENGTH:
            raise Exception("Invalid BLS key length.")
    # All validator keys must be distinct.
    if len(validatorKeys) != len(set(validatorKeys)):
        raise Exception("Duplicate BLS keys.")
    
    # Validator kyes must be in lexiographic order.
    if not all(validatorKeys[i] < validatorKeys[i + 1] for i in range(len(validatorKeys) - 1)):
        raise Exception("Validator keys are not in lexicographic order.")

    certificate = decode(certificateSchema, certificateBytes)
    # Update validator list using updateActiveValidators defined below.
    newActiveValidators = updateActiveValidators(validators(partnerchainID).activeValidators, ccu.params.activeValidatorsUpdate)
    if ccu.params.newCertificateThreshold > 0:
        newCertificateThreshold = ccu.params.newCertificateThreshold
    else:
        newCertificateThreshold = validators(partnerchainID).certificateThreshold
    # computeValidatorsHash is defined in LIP 0058.
    if certificate.validatorsHash == bft.computeValidatorsHash(newActiveValidators, newCertificateThreshold):
        raise Exception("Validators hash does not match.")
```

```python
def updateActiveValidators(activeValidators: list[ActiveValidator], activeValidatorsUpdate: list[ActiveValidator]) -> list[ActiveValidator]:
    for validator in activeValidatorsUpdate:
        for currentValidator in activeValidators:
            if currentValidator.blsKey == validator.blsKey:
                currentValidator.bftWeight = validators.bftWeight
        else:
            add validator to activeValidators maintaining the entries in lexicographical order of blsKeys

    #remove any entry activeValidators with bftWeight == 0
    for validator in activeValidators:
        if validator.bftWeight == 0:
            activeValidators.remove(validator)
    return activeValidators
```

#### InboxUpdate Validity

```python
def verifyInboxUpdate(ccu: CCU) -> None:
    partnerchainID = ccu.params.sendingChainID
    inboxTree = Merkle tree of channel(partnerchainID).inbox
    # Update inbox by appending all cross-chain messages.
    # crossChainMessages can be empty.
    for ccm in ccu.params.inboxUpdate.crossChainMessages:
        inboxTree.append(SHA-256(appendData))
    newInboxRoot = inboxTree.root

    # If the message witness is non-empty, update the inbox root.
    messageWitnessHashes = ccu.params.inboxUpdate.messageWitnessHashes
    if len(messageWitnessHashes) > 0:
        # calculateRootFromRightWitness is specified in LIP 0031.
        newInboxRoot = calculateRootFromRightWitness(inboxTree.size, inboxTree.appendPath, messageWitnessHashes)

    certificateBytes = ccu.params.certificate
    # Verification for non-empty certificates.
    if len(certificateBytes) > 0:
        queryKeys = [outboxKey]
        outboxRootWitness = ccu.params.inboxUpdate.outboxRootWitness
        proof = {
            siblingHashes: outboxRootWitness.siblingHashes,
            queries: [{
                key: outboxKey,
                value: newInboxRoot,
                bitmap: outboxRootWitness.bitmap
            }],
        }

        outboxKey = MODULE_ID_INTEROPERABILITY + STORE_PREFIX_OUTBOX_ROOT + SHA-256(partnerchainID)
        # verify is specified in LIP 0039.
        if verify(queryKeys, proof, certificate.stateRoot) == False:
            raise Exception("Invalid inclusion proof for inbox update.")
    
    # Verification for empty certificates.
    elif len(certificateBytes) == 0:
        if newInboxRoot != channel(partnerchainID).partnerChainOutboxRoot:
            raise Exception("Inbox root does not match partner chain outbox root.")
```

## Backwards Compatibility

This proposal, together with [LIP 0043][lip-0043], [LIP 0049][lip-0049], and [LIP 0054][lip-0054], is part of the Interoperability module. Chains adding this module will need to do so with a hard fork.

## Reference Implementation

TBA

## Appendix

### Computing the Validators Update

When posting a CCU transaction, the validators hash given in the certificate certifies the new set of validators of the sending chain. The CCU must therefore include the difference between the validators currently stored in the chain account and the validator set authenticated by the certificate. The required `activeValidatorsUpdate` can be obtained by applying the function below.

```python
def getActiveValidatorsDiff(currentValidators: list[ActiveValidator], newValidators: list[ActiveValidator]) -> list[ActiveValidator]:
    activeValidatorsUpdate = []

    for validator in newValidators:
        if validator not in currentValidators:
            activeValidatorsUpdate.append(validator)

    currentKeys = [validator.blsKey for validator in currentValidators]
    for validator in currentValidators:
        if validator.blsKey not in currentKeys:
            activeValidatorsUpdate.append({"blsKey": currentValidator.blsKey, "bftWeight": 0})

    return activeValidatorsUpdate
```

[lip-0031#rightWitness]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0031.md#appendix-d-right-witness-implementation
[lip-0038]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0038.md
[lip-0038#verifyWeightedAggSig]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0038.md#aggregate-signatures-and-their-verification
[lip-0039]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0039.md
[lip-0043]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0043.md
[lip-0045]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0045.md
[lip-0045#appendToInboxTree]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0045.md#appendtoinboxtree
[lip-0045#livenessCondition]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0045.md#liveness-condition
[lip-0045#terminateChainInternal]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0045.md#terminatechaininternal
[lip-0045#termination]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0045.md#terminatechain
[lip-0049]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0049.md
[lip-0049#apply]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0049.md#apply
[lip-0049#bounce]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0049.md#bounce
[lip-0049#ccmSchema]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0049.md#cross-chain-message-schema
[lip-0049#forward]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0049.md#forward
[lip-0049#registrationMessage]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0049.md#registration-message
[lip-0049#validateFormat]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0049.md#validateformat
[lip-0051]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0051.md
[lip-0054]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0054.md
[lip-0055]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0055.md
[lip-0061]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0061.md
[lip-0061#certificate-schema]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0061.md#schema