```
LIP: 0043
Title: Introduce chain registration mechanism
Author: Iker Alustiza <iker@lightcurve.io>
Discussions-To: https://research.lisk.com/t/chain-registration
Status: Draft
Type: Standards Track
Created: 2021-05-22
Updated: 2022-03-22
Requires: 0038, 0045, 0049, 0056
```

## Abstract

This LIP introduces the concept of chain registration in the Lisk ecosystem. The chain registration is a necessary step to make a sidechain interoperable with the Lisk mainchain. Specifically, for the Lisk mainchain, this LIP specifies a new command for the sidechain registration. This command creates a sidechain account in the Lisk mainchain with some specific properties given by the user submitting the transaction. Similarly for sidechains, this LIP specifies the mainchain registration command.

## Copyright

This LIP is licensed under the [Creative Commons Zero 1.0 Universal][creative].

## Motivation

The Lisk ecosystem is a permissionless network of blockchains where a sidechain following the standard protocol can interoperate with any other Lisk compatible chain. In particular, the Lisk mainchain serves as a central node or relayer for the entire ecosystem and every cross-chain interaction has to be sent through it. This implies there should exist a standardized protocol for the Lisk mainchain to maintain a _cross-chain channel_ to communicate with every sidechain.

The first step for establishing this _cross-chain channel_ protocol is the chain registration process, which can be thought of as the creation/opening of the channel between two chains. This process defines the data structures, and protocol rules that every chain needs to implement in the ecosystem if they want to interoperate with another specific chain.

For a general picture of the Lisk interoperability architecture, please refer to [LIP 0045][lip-0045].

## Rationale

In this LIP, the registration process introduced in the previous section is specified from the point of view of both the Lisk mainchain and sidechains. For the Lisk mainchain, this is done by the sidechain registration command, whereas for sidechains, it is done by the mainchain registration command.

### Sidechain Registration Process

As mentioned above, for a sidechain to be interoperable in the Lisk ecosystem, it has to be registered in the Lisk Mainchain via a sidechain registration command. A transaction with this command can be sent by any user account in the Lisk Mainchain with enough funds to pay the required fee. The processing of this command implies the creation of a _sidechain account_ in the mainchain state associated with a unique network identifier and a name. This means that every new sidechain occupies a certain namespace in the ecosystem. Additionally, every newly registered sidechain can increase the size of every cross-chain update command posted on the mainchain (due to the increasing size of the [`outboxRootWitness`][lip-0053#outbox-root-witness] property of the command). For these two reasons, the minimum fee for this command has an added constant similar to the extra fee in a [delegate registration command][docs:delegate]. The value of this extra registration fee is 10 LSK.

Once the sidechain registration command is processed, the sidechain account status is set to _registered_. In this state, the cross-chain channel is still not active, so the users on the mainchain or other chains cannot send [cross-chain messages (CCMs)][lip-0049] to this sidechain yet. Moreover, the [liveness requirement][lip-0045#liveness-condition] to maintain the channel is not enforced, this means that there is no specific time requirement for a sidechain to be activated on the mainchain, it can stay in the registered status for any period of time.  When a first valid cross-chain update command from this sidechain is processed, the sidechain status is changed to _active,_ making it active in the ecosystem. Now it is possible to send CCMs to the sidechain and the liveness condition is enforced.

#### Sidechain Structures on Mainchain

When a new sidechain is registered on the mainchain via a sidechain registration command, it is assigned a chain ID, a unique integer that identifies the sidechain in the ecosystem. Furthermore, new data structures are inserted for the sidechain in the Lisk mainchain state. Specifically, a new entry is created in six different substores of the interoperability module store (see Figure 1): [outbox root substore][lip-0045#outbox-substore], [chain data substore][lip-0045#chain-substore], [channel data substore][lip-0045#channel-substore], [chain validators substore][lip-0045#validators-substore], [registered names][lip-0045#names-substore], and [registered network IDs][lip-0045#networkIDs-substore]. The values of these entries are initialized as specified in [LIP 0045][lip-0045].

![interoperability_store](lip-0043/interoperability_store.png)

_Figure 1: A summary of the Interoperability module store: Each box represents a substore, where we indicate the `storeKey --> storeValue` relation. For the Lisk mainchain, the 'own chain' substore exists by default in the state whereas there is one entry per registered sidechain for six other substores (outbox root, chain data, channel data, chain validators, registered names, and registered network IDs) created by a sidechain registration command. For sidechains, the 'own chain' and one entry for the mainchain account for four other substores (outbox root, chain data, channel data, and chain validators) are created by the mainchain registration command._

#### Sidechain Registration Command

The sidechain registration command contains the following parameters used to connect a new sidechain in the ecosystem.

##### name

The `name` property sets the name of the sidechain as a string of characters. It has to be unique in the ecosystem.

##### genesisBlockId

The ID of the genesis block (as defined in [LIP 0034][lip-0034]). It is computed from the SHA-256 digest of the serialized bytes of the sidechain genesis block. It can also help future sidechain node operators to identify the sidechain genesis block with respect to its value.

##### initValidators

This property defines the set of eligible [BLS public keys][lip-0038] with their respective [BFT weights][lip-0056] required to sign the first certificate from the sidechain.

##### certificateThreshold

The `certificateThreshold` property is an integer setting the required cumulative weight needed for a certificate signature from the sidechain to be valid.

#### Chain ID

The chain ID uniquely identifies a chain in the Lisk ecosystem. It serves a similar purpose for chains as [addresses][docs:address] do for user accounts. The chain ID for a sidechain is deterministically computed when processing the sidechain registration command. Specifically, the chain ID of a new sidechain is assigned as an incremental integer similar to [transaction nonces][docs:nonces]. For example, if there are 41 chains already registered in the Lisk ecosystem (the mainchain and 40 sidechains), the next registered sidechain will have `chainID = 42`. The chain ID has to be stated in every cross-chain interaction. For example, it has to be specified in the `receivingChainID` property of a CCM to this sidechain and in the `sendingChainId` property of a cross-chain update command from this sidechain.

The format of chain IDs aims to provide an efficient and compact way to uniquely identify chains in the ecosystem. This has another advantage in terms of usability: Users can easily remember the integer assigned as chain ID for their favorite blockchain applications.

#### Sidechain Network Identifier

The network identifier, or network ID, is a byte sequence unique to a chain that has to be prepended to the input of the signing function of every transaction, block, or message of the chain. It is necessary to avoid transaction replays between different chains in the ecosystem.

In the Lisk ecosystem, the network ID for a sidechain is computed as the hash digest of the sidechain genesis block ID given in a transaction with the registration command and the address of the account sending this transaction. This is convenient for two reasons:

1. The sidechain developers can pre-compute the network ID of their sidechain as soon as they set the genesis block and an account to send the transaction on the mainchain. The sidechain can be started already from this moment without being registered on the mainchain.
2. The network ID is known to the mainchain as soon as the sidechain is registered, thus it can validate cross-chain update commands coming from the sidechain without further context.

This LIP overwrites the network ID definition given in [LIP 0009][lip-0009] and solves the open problem given in the [Rationale section][lip-0009#rationale] of that LIP. Note that in the case of a sidechain undergoing a community hard fork, one of the competing forks will need to register their fork of the sidechain again on the Lisk Mainchain. Regardless of the genesis block ID set by this sidechain fork, it has to be registered from a different user account which implies that the chain ID and network ID of the forked chain will be different from the original one.

### Mainchain Registration on a Sidechain

Once the sidechain has been registered on the mainchain, a similar registration process should happen in the sidechain before the interoperable channel is opened between the two chains. This is done by submitting a transaction with the mainchain registration command in the sidechain, which implies the creation of a _mainchain account_ in the sidechain state associated with the Lisk mainchain and other structures needed for interoperability. This mainchain account has a similar structure as the one depicted in Figure 1. By protocol, the chain ID of the mainchain is a constant equal to 1 in the ecosystem. The network ID of the mainchain is also a constant since it has to be known to validate cross-chain update commands.

This registration process has to happen always after the sidechain registration on the mainchain since the sidechain has no prior knowledge of the current mainchain validators or its own chain ID and name. Similar to the sidechain registration case, the _mainchain account_ status will not change to active until a valid cross-chain update command from the mainchain containing a valid [registration CCM][lip-0049] is processed.

#### Mainchain Registration Command

The mainchain registration command sets certain parameters in the sidechain related to the interoperability module and initializes the corresponding mainchain data structures. This command requires the approval of the sidechain validators. They have to agree on the content of this command and add their aggregated signatures accordingly. It is important that the sidechain validators make sure that they are signing the registration command with the right information from the mainchain, otherwise, the sidechain interoperable functionality may be unusable.

This command has no requirement for a minimum fee since it should be submitted only once in a sidechain and approved by a majority of validators. For this reason, a transaction with this command should be treated differently in terms of priority in case it is included in a sidechain node’s transaction pool. The recommendation is that, once the transaction is properly signed by the validators and ready to be submitted, a validator simply includes it in its next forged block without including it in the transaction pool. The command has the following parameters:

##### mainchainValidators

Similar to the `initValidators` property in the sidechain registration command, it defines the set of mainchain validators with their respective BFT weight expected to sign the first certificate from the mainchain.

##### ownChainID

The chain ID assigned to this sidechain on the mainchain after processing the corresponding sidechain registration command.

##### ownName

The `ownName` property sets the name of the sidechain in its own state according to the name given in the mainchain.

## Specification

### Constants and Notation

| Name                                  | Type   | Value                | Description                                        |
|---------------------------------------|--------| ---------------------|----------------------------------------------------|
| **Interoperability Constants**        |        |                      |                                                    |
| `MODULE_ID_INTEROPERABILITY`          | bytes  | TBD                  | ID of the interoperability module.                 |
| `OWN_CHAIN_ID`                        | bytes  | 0x00000000           | Local chain ID of the chain.                                     |
| `MAINCHAIN_ID`                        | bytes  | 0x00000001           | Chain ID of the Lisk mainchain.                    |
| `MAINCHAIN_NAME`                      | string | "lisk-mainchain"     | Name of the Lisk mainchain.                        |
| `MAINCHAIN_NETWORK_ID`                | bytes  | TBD                  | Network identifier of the Lisk mainchain.          |
 **Interoperability Store**             |        |                      |                                                    |
| `STORE_PREFIX_OUTBOX_ROOT`            | bytes  | 0x0000               | Store prefix of the outbox root substore.          |
| `STORE_PREFIX_CHAIN_DATA`             | bytes  | 0x8000               | Store prefix of the chain data substore.           |
| `STORE_PREFIX_CHANNEL_DATA`           | bytes  | 0xa000               | Store prefix of the channel data substore.         |
| `STORE_PREFIX_CHAIN_VALIDATORS`       | bytes  | 0xb000               | Store prefix of the chain validators substore.     |
| `STORE_PREFIX_TERMINATED_STATE`       | bytes  | 0xc000               | Store prefix of the terminated state substore.     |
| `STORE_PREFIX_TERMINATED_OUTBOX`      | bytes  | 0xd000               | Store prefix of the terminated outbox substore.    |
| `STORE_PREFIX_REGISTERED_NAMES`       | bytes  | 0xe000               | Store prefix of the chain names substore.          |
| `STORE_PREFIX_REGISTERED_NETWORK_IDS` | bytes  | 0xf000               | Store prefix of the chain network IDs substore.    |
| **Interoperability Command IDs**      |        |                      |                                                    |
| `COMMAND_ID_SIDECHAIN_REG`            | bytes  | 0x0000               | Command ID of sidechain registration command.      |
| `COMMAND_ID_MAINCHAIN_REG`            | bytes  | 0x0001               | Command ID of mainchain registration command.      |
| `CROSS_CHAIN_COMMAND_ID_REGISTRATION` | bytes  | 0x0000               | Cross-chain command ID of chain registration CCM.  |
| **General Constants**                 |        |                      |                                                    |
| `REGISTRATION_FEE`                    | uint64 | 1000000000           | Fee to pay for a sidechain registration command.   |
| `MAX_NUM_VALIDATORS`                  | uint32 | 199                  | Maximum number of validators in a sidechain.       |
| `MAX_LENGTH_NAME`                     | uint32 | 40                   | Maximum allowed name for a sidechain.              |
| `MAX_UINT32`                          | uint32 | 4294967295           | Maximum value for a 32-bit unsigned integer.       |
| `MAX_UINT64`                          | uint64 | 18446744073709551615 | Maximum value for a 64-bit unsigned integer.       |
| `THRESHOLD_MAINCHAIN`                 | uint32 | `68`                 | The certificate threshold used for Lisk mainchain. |
| `MESSAGE_TAG_CHAIN_REG`               | bytes  | ASCII encoded string `“LSK_CHAIN_REGISTRATION_”`. | Message tag for chain registration message |
| `TOKEN_ID_LSK_MAINCHAIN`              | bytes  | 0x0000000000000000   | The token ID of the Lisk token. |
| `MAINCHAIN_NUMBER_ACTIVE_DELEGATES` 	| uint32 |	101 |	The number of active delegates on the Lisk mainchain. |

#### Functions from Other Modules

Calling a function `fct` from a module `module` is represented by `module.fct(required inputs)`. In this LIP, functions from the [Validators module][lip-0044] and the [BFT module][lip-0058] are used.

### Sidechain Registration Command

Transactions executing this command have:

* `moduleID = MODULE_ID_INTEROPERABILITY`,
* `commandID = COMMAND_ID_SIDECHAIN_REG`.

#### Parameters

```java
sidechainRegParams = {
    "type": "object",
    "required": [
        "name",
        "genesisBlockID",
        "initValidators",
        "certificateThreshold",
        "extraCommandFee"
    ],
    "properties": {
        "name": {
            "dataType": "string",
            "fieldNumber": 1
        },
        "genesisBlockID": {
            "dataType": "bytes",
            "length": HASH_LENGTH,
            "fieldNumber": 2
        },
        "initValidators": {
            "type": "array",
            "fieldNumber": 3,
            "items": {
                "type": "object",
                "required": ["blsKey", "bftWeight"],
                "properties": {
                    "blsKey": {
                        "dataType": "bytes",
                        "length": BLS_PUBLIC_KEY_LENGTH,
                        "fieldNumber": 1
                    },
                    "bftWeight": {
                        "dataType": "uint64",
                        "fieldNumber": 2
                    }
                }
            }
        },
        "certificateThreshold": {
            "dataType": "uint64",
            "fieldNumber": 4
        },
        "extraCommandFee": {
            "type": "uint64",
            "fieldNumber": 5
        }
    }
}
```

#### Verification

```python
def verify(trs: Transaction) -> None:
    # The name property has to contain only characters from the set [a-z0-9!@$&_.].
    if not re.match(r"^[a-z0-9!@$&_.]+$", trs.params.name):
        raise Exception("Invalid name property. It should contain only characters from the set [a-z0-9!@$&_.].")
    # The name property has to be at most MAX_LENGTH_NAME characters long.
    if len(trs.params.name) > MAX_LENGTH_NAME:
        raise Exception(f"Invalid name property. It should be at most {MAX_LENGTH_NAME} characters long.")
    # The name property has to be unique with respect to the set of already registered sidechain names.
    if there exists an entry in the registered names substore with store key equal to trs.params.name.encode("utf-8"):
        raise Exception("Name already registered.")

    # Network ID has to be unique with respect to the set of already registered sidechain network IDs.
    senderAddress = SHA-256(trs.senderPublicKey)[:ADDRESS_LENGTH]
    netId = SHA-256(trs.params.genesisBlockId + senderAddress)
    if there exists an entry in the registered network IDs substore with store key equal to netId:
        raise Exception("Network ID already registered.")
    
    # initValidators must have at least 1 element and at most MAX_NUM_VALIDATORS elements.
    if len(trs.params.initValidators) < 1 or len(trs.params.initValidators) > MAX_NUM_VALIDATORS:
        raise Exception(f"Invalid initValidators array. It must have at least 1 element and at most {MAX_NUM_VALIDATORS} elements.")
    
    validatorKeys = [validator["blsKey"] for validator in trs.params.initValidators]
    # All validator keys must be valid BLS keys.
    for key in validatorKeys:
        if len(key) != PUBLIC_KEY_BLS_LENGTH:
            raise Exception("Invalid BLS key length.")
    # All validator keys must be distinct.
    if len(validatorKeys) != len(set(validatorKeys)):
        raise Exception("Duplicate BLS keys.")
    
    # Validator keys must be in lexicographic order.
    if not all(validatorKeys[i] < validatorKeys[i + 1] for i in range(len(validatorKeys) - 1)):
        raise Exception("Validator keys are not in lexicographic order.")
    
    totalWeight = 0
    for validator in trs.params.initValidators:
        # The bftWeight property of each element is a positive integer.
        if validator["bftWeight"] == 0:
            raise Exception("Invalid bftWeight property.")
        totalWeight += validator["bftWeight"]
    # Total BFT weight has to be less than or equal to MAX_UINT64.
    if totalWeight > MAX_UINT64:
        raise Exception("Total BFT weight exceeds maximum value.")
    
    # The range of valid values of the certificateThreshold property is given by the total sum of the validators weights:
    # Minimum value: floor(1/3 * total BFT weight) + 1.
    # Maximum value = total BFT weight.
    if trs.params.certificateThreshold < floor(1/3 * totalWeight) + 1:
        raise Exception("Certificate threshold is too small.")
    if trs.params.certificateThreshold > totalWeight:
        raise Exception("Certificate threshold is too large.")

    # extraCommandFee must equal REGISTRATION_FEE.
    if trs.params.extraCommandFee != REGISTRATION_FEE:
        raise Exception("Invalid extra command fee.")
    # Sendermust have enough balance to pay for extra command fee.
    senderAddress = SHA-256(trs.senderPublicKey)[:ADDRESS_LENGTH]
    if Token.getAvailableBalance(senderAddress, TOKEN_ID_LSK_MAINCHAIN) < REGISTRATION_FEE:
        raise Exception("Sender does not have enough balance.")
```

#### Execution

```python
def execute(trs: Transaction) -> None:
    currentHighestChainID = highest chain ID among all registered chains (Lisk mainchain included)
    chainID = currentHighestChainID + 1
    senderAddress = SHA-256(trs.senderPublicKey)[:ADDRESS_LENGTH]

    # Create chain account.
    sidechainAccount = {
        "name": trs.params.name,
        "networkID": SHA-256(trs.params.genesisBlockId + senderAddress),
        "lastCertificate": {
            "height": 0,
            "timestamp": 0,
            "stateRoot": EMPTY_BYTES,
            "validatorsHash": bft.computeValidatorsHash(trs.params.initValidators, trs.params.certificateThreshold)
        },
        "status": CHAIN_STATUS_REGISTERED
    }
    create an entry in the chain data substore with
        storeKey = chainID
        storeValue = encode(chainAccountSchema, sidechainAccount)

    # Create channel.
    sidechainChannel = {
        "inbox": {
            "appendPath": [],
            "size": 0,
            "root": EMPTY_BYTES
        },
        "outbox": {
            "appendPath": [],
            "size": 0,
            "root": EMPTY_BYTES
        },
        "partnerChainOutboxRoot": EMPTY_BYTES,
        "messageFeeTokenID": TOKEN_ID_LSK_MAINCHAIN
    }
    create an entry in the channel data substore with
        storeKey = chainID
        storeValue = encode(channelSchema, sidechainChannel)

    # Create validators account.
    sidechainValidators = {
        "activeValidators": trs.params.initValidators,
        "certificateThreshold": trs.params.certificateThreshold
    }
    create an entry in the chain validators data substore with
        storeKey = chainID
        storeValue = encode(validatorsSchema, sidechainValidators)

    # Create outbox root entry.
    create an entry in the outbox root substore with
        storeKey = chainID
        storeValue = encode(outboxRootSchema, {"root": sidechainChannel.outbox.root})

    # Create registered names entry.
    create an entry in the registered names substore with
        storeKey = trs.params.name
        storeValue = encode(chainIDSchema, {"ID": chainID})

    # Create registered network IDs entry.
    create an entry in the registered network IDs substore with
        storeKey = sidechainAccount.networkID
        storeValue = encode(chainIDSchema, {"ID": chainID})

    # Burn the registration fee.
    Token.burn(senderAddress, TOKEN_ID_LSK_MAINCHAIN, REGISTRATION_FEE)

    # Emit chain account updated event.
    emitEvent(
        moduleID = MODULE_ID_INTEROPERABILITY,
        typeID = TYPE_ID_CHAIN_ACCOUNT_UPDATED,
        data = sidechainAccount,
        topics = [chainID]
    )

    # Send registration CCM to the sidechain.
    registrationCCMParams = {
        "networkID": sidechainAccount.networkID,
        "name": trs.params.name,
        "messageFeeTokenID": sidechainChannel.messageFeeTokenID
    }
    send(EMPTY_FEE_ADDRESS, 
        MODULE_ID_INTEROPERABILITY, 
        CROSS_CHAIN_COMMAND_ID_REGISTRATION, 
        chainID, 
        0, 
        CCM_STATUS_OK, 
        registrationCCMParams
    )
```

### Mainchain Registration Command

Transactions executing this command have:

* `moduleID = MODULE_ID_INTEROPERABILITY`,
* `commandID = COMMAND_ID_MAINCHAIN_REG`.

#### Parameters

```java
mainchainRegParams = {
    "type": "object",
    "required": [
        "ownChainID",
        "ownName",
        "mainchainValidators",
        "signature",
        "aggregationBits"
    ],
    "properties": {
        "ownChainID": {
            "dataType": "bytes",
            "length": CHAIN_ID_LENGTH,
            "fieldNumber": 1
        },
        "ownName": {
            "dataType": "string",
            "fieldNumber": 2
        },
        "mainchainValidators": {
            "type": "array",
            "fieldNumber": 3,
            "items": {
                "type": "object",
                "required": ["blsKey", "bftWeight"],
                "properties": {
                    "blsKey": {
                        "dataType": "bytes",
                        "length": BLS_PUBLIC_KEY_LENGTH,
                        "fieldNumber": 1
                    },
                    "bftWeight": {
                        "dataType": "uint64",
                        "fieldNumber": 2
                    }
                }
            }
        },
        "signature": {
            "dataType": "bytes",
            "length": BLS_SIGNATURE_LENGTH,
            "fieldNumber": 4
        },
        "aggregationBits": {
            "dataType": "bytes",
            "fieldNumber": 5
        }
    }
}
```

#### Verification

```python
def verify(trs: Transaction) -> None:
    # The ownChainID property has to be an integer less than or equal to MAX_UINT32.
    if trs.params.ownChainID > MAX_UINT32:
        raise Exception("Invalid ownChainID property.")

    # The ownName property has to contain only characters from the set [a-z0-9!@$&_.].
    if not re.match(r"^[a-z0-9!@$&_.]+$", trs.params.ownName):
        raise Exception("Invalid ownName property. It should contain only characters from the set [a-z0-9!@$&_.].")
    # The name property has to be at most MAX_LENGTH_NAME characters long.
    if len(trs.params.ownName) > MAX_LENGTH_NAME:
        raise Exception(f"Invalid ownName property. It should be at most {MAX_LENGTH_NAME} characters long.")

    # mainchainValidators must have exactly MAINCHAIN_NUMBER_ACTIVE_VALIDATORS elements.
    if len(trs.params.mainchainValidators) != MAINCHAIN_NUMBER_ACTIVE_VALIDATORS:
        raise Exception(f"Invalid mainchainValidators property. It must have exactly {MAINCHAIN_NUMBER_ACTIVE_VALIDATORS} elements.")
    
    validatorKeys = [validator["blsKey"] for validator in trs.params.initValidators]
    # All validator keys must be valid BLS keys.
    for key in validatorKeys:
        if len(key) != PUBLIC_KEY_BLS_LENGTH:
            raise Exception("Invalid BLS key length.")
    # All validator keys must be distinct.
    if len(validatorKeys) != len(set(validatorKeys)):
        raise Exception("Duplicate BLS keys.")
    
    # Validator keys must be in lexicographic order.
    if not all(validatorKeys[i] < validatorKeys[i + 1] for i in range(len(validatorKeys) - 1)):
        raise Exception("Validator keys are not in lexicographic order.")
    
    for validator in trs.params.initValidators:
        # The bftWeight property of each element is equal to 1.
        if validator["bftWeight"] != 1:
            raise Exception("Invalid bftWeight property.")
    
    # Check signature property.
    height = height of the block in which trs was included
    validators = BFT.getBFTParameters(b.header.height).validators
    certificateThreshold = BFT.getBFTParameters(b.header.height).certificateThreshold
    networkID = networkID of the chain
    # Sort validators by BLS key.
    validators.sort(key=lambda validator: validatorsModule.getValidatorAccount(validator.address).blsKey)
    blsKeys = [validatorsModule.getValidatorAccount(validator.address).blsKey for validator in validators]
    bftWeights = [validator.bftWeight for validator in validators]
    
    registrationSignatureMessageSchema = {  
        "type": "object",
        "required": ["ownChainID", "ownName", "mainchainValidators"],
        "properties": {
            "ownChainID": {
                "dataType": "bytes",
                "length": CHAIN_ID_LENGTH,
                "fieldNumber": 1
            },
            "ownName": {
                "dataType": "string",
                "fieldNumber": 2
            },
            "mainchainValidators": {
                "type": "array",
                "fieldNumber": 3,
                "items": {
                    "type": "object",
                    "required": ["blsKey", "bftWeight"],
                    "properties": {
                        "blsKey": {
                            "dataType": "bytes",
                            "length": BLS_PUBLIC_KEY_LENGTH,
                            "fieldNumber": 1
                        },
                        "bftWeight": {
                            "dataType": "uint64",
                            "fieldNumber": 2
                        }
                    }
                }
            }
        }
    }

    message = encode(registrationSignatureMessageSchema, 
        {
        "ownChainID": trs.params.ownChainID,
        "ownName": trs.params.ownName,
        "mainchainValidators": trs.params.mainchainValidators
        }
    )

    # verifyWeightedAggSig is specified in LIP 0038.
    if verifyWeightedAggSig(blsKeys, MESSAGE_TAG_CHAIN_REG, networkID, trs.params.aggregationBits, trs.params.signature, bftWeights, certificateThreshold, message) == VALID:
        raise Exception("Invalid signature property.")
```


#### Execution

```python
def execute(trs: Transaction) -> None:
    # Create chain account.
    mainchainAccount = {
        "name": MAINCHAIN_NAME,
        "networkID": MAINCHAIN_NETWORK_ID,
        "lastCertificate": {
            "height": 0,
            "timestamp": 0,
            "stateRoot": EMPTY_BYTES,
            "validatorsHash": bft.computeValidatorsHash(trs.params.mainchainValidators, THRESHOLD_MAINCHAIN)
        },
        "status": CHAIN_STATUS_REGISTERED
    }
    create an entry in the chain data substore with
        storeKey = MAINCHAIN_ID
        storeValue = encode(chainAccountSchema, mainchainAccount)

    # Create channel.
    mainchainChannel = {
        "inbox": {
            "appendPath": [],
            "size": 0,
            "root": EMPTY_BYTES
        },
        "outbox": {
            "appendPath": [],
            "size": 0,
            "root": EMPTY_BYTES
        },
        "partnerChainOutboxRoot": EMPTY_BYTES,
        "messageFeeTokenID": TOKEN_ID_LSK_MAINCHAIN
    }
    create an entry in the channel data substore with
        storeKey = MAINCHAIN_ID
        storeValue = encode(channelSchema, mainchainChannel)

    # Create validators account.
    mainchainValidators = {
        "activeValidators": trs.params.mainchainValidators,
        "certificateThreshold": THRESHOLD_MAINCHAIN
    }
    create an entry in the chain validators data substore with
        storeKey = MAINCHAIN_ID
        storeValue = encode(validatorsSchema, mainchainValidators)

    # Create outbox root entry.
    create an entry in the outbox root substore with
        storeKey = MAINCHAIN_ID
        storeValue = encode(outboxRootSchema, {"root": mainchainChannel.outbox.root})

    # Create own chain account.
    ownChainAccount = {
        "name": trs.params.ownName,
        "ID": trs.params.ownChainID,
        "nonce": 0
    }
    create an entry in the own chain data substore with
        storeKey = EMPTY_BYTES
        storeValue = encode(ownChainAccountSchema, ownChainAccount)

    # Emit chain account updated event.
    emitEvent(
        moduleID = MODULE_ID_INTEROPERABILITY,
        typeID = TYPE_ID_CHAIN_ACCOUNT_UPDATED,
        data = mainchainAccount,
        topics = [MAINCHAIN_ID]
    )

    # Send registration CCM to the mainchain.
    registrationCCMParams = {
        "networkID": MAINCHAIN_NETWORK_ID,
        "name": MAINCHAIN_NAME,
        "messageFeeTokenID": mainchainChannel.messageFeeTokenID
    }
    send(
        EMPTY_FEE_ADDRESS, 
        MODULE_ID_INTEROPERABILITY, 
        CROSS_CHAIN_COMMAND_ID_REGISTRATION, 
        MAINCHAIN_ID, 
        0, 
        CCM_STATUS_OK, 
        registrationCCMParams
    )
```

## Backwards Compatibility

This proposal, together with [LIP 0045][lip-0045], [LIP 0053][lip-0053], [LIP 0049][lip-0049], and [LIP 0054][lip-0054], is part of the Interoperability module. Chains adding this module will need to do so with a hardfork.

## Reference Implementation

TBA

[creative]: https://creativecommons.org/publicdomain/zero/1.0/
[docs:address]: https://lisk.com/documentation/lisk-sdk/protocol/accounts.html#address
[docs:delegate]: https://lisk.com/documentation/lisk-sdk/protocol/transactions.html#delegate
[docs:nonces]: https://lisk.com/documentation/lisk-sdk/protocol/transactions.html#nonce
[lip-0009]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0009.md
[lip-0009#rationale]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0009.md#rationale
[lip-0027]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0027.md
[lip-0034]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0034.md
[lip-0038]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0038.md
[lip-0044]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0044.md
[lip-0045]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0045.md
[lip-0045#chain-substore]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0045.md#chain-data-substore
[lip-0045#channel-substore]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0045.md#channel-data-substore
[lip-0045#liveness-condition]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0045.md#liveness-condition
[lip-0045#names-substore]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0045.md#registered-names-substore
[lip-0045#networkIDs-substore]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0045.md#registered-network-ids-substore
[lip-0045#outbox-substore]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0049.md#outbox-root-substore
[lip-0045#validators-substore]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0045.md#chain-validators-substore
[lip-0049]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0049.md
[lip-0049#registration-message]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0049.md#registration-message-1
[lip-0053]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0053.md
[lip-0053#outbox-root-witness]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0053.md#outboxrootwitness
[lip-0054]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0054.md
[lip-0056]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0056.md
[lip-0058]: https://github.com/LiskHQ/lips/blob/main/proposals/lip-0058.md
