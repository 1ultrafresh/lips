```
LIP: 0041
Title: Introduce Auth module
Author: Alessandro Ricottone <alessandro.ricottone@lightcurve.io>
        Ishan Tiwari <ishan.tiwari@lightcurve.io>
Discussions-To: https://research.lisk.com/t/introduce-auth-module
Status: Draft
Type: Standards Track
Created: 2021-07-27
Updated: 2022-01-10
Requires: 0040
```

## Abstract

The Auth module is responsible for handling and verifying nonces and for transaction signature validation, including transactions from multisignature accounts. In this LIP, we specify the properties of the Auth module, along with their serialization and default values. Furthermore, we specify the state transitions logic defined within this module, i.e. the commands, the protocol logic injected during the block lifecycle, and the functions that can be called from other modules or off-chain services.

## Copyright

This LIP is licensed under the [Creative Commons Zero 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).

## Motivation

In the Lisk protocol, some verification steps are common to all transactions. In particular, to validate a transaction it is necessary to validate the [signatures](https://lisk.com/documentation/lisk-sdk/protocol/accounts.html#keys) and the [nonce](https://lisk.com/documentation/lisk-sdk/protocol/accounts.html#nonce). These validation steps are handled by the authentication (auth) module.

In this LIP we specify the properties, serialization, and default values of the Auth module, as well as the protocol logic processed during a block lifecycle, the commands, and the functions exposed to other modules and to off-chain services.

## Rationale

Validating a transaction requires reading the state to get the nonce and possibly the multisignature keys from the user account. Since both these checks are necessarily done together, it makes sense to store these values together, to reduce the number of database accesses.

## Specification

In this section, we specify the substores that are part of the Auth module store, the commands, and the protocol logic called during the block lifecycle. The Auth module has module ID `MODULE_ID_AUTH` (see the [table below](#constants)).

### Constants

We define the following constants:

| Name               | Type    | Value       | Description                             |
| ------------------ |---------| ------------| ----------------------------------------|
|`MODULE_ID_AUTH`    | bytes  | TBD         | ID of the Auth module.                  |
|`STORE_PREFIX_AUTH` | bytes   | 0x0000      | Store prefix of the auth data substore. |
|`COMMAND_ID_REGISTER_MULTISIGNATURE_GROUP` | bytes   | 0x0000      | Command ID of the register multisignature group command. |
|`TYPE_ID_MULTISIGNATURE_GROUP_REGISTERED` | bytes   | 0x0000      | Type ID of the signature group registered event. |
|`MULTISIGNATURE_MSG_TAG` | bytes   | "LSK_RMSG_" as ASCII-encoded literal      | Message tag for the signatures contained in the register multisignature group command. |


### Auth Module Store

The key-value pairs in the module store are organized in the following substore.

#### Auth Data Substore

##### Store Prefix, Store Key, and Store Value

* The store prefix is set to `STORE_PREFIX_AUTH`.
* Store keys are set to 20 bytes addresses, representing a user address.
* Store values are set to _auth account_ data structures, holding the properties indicated [below](#properties-and-default-values), serialized using the JSON schema `authAccountSchema`, presented [below](#json-schema).
* Notation: For the rest of this proposal let `authAccount(address)` be an entry in the auth data substore identified by the store key `address`.

##### JSON Schema

```java
authAccountSchema = {
    "type": "object",
    "required": ["nonce", "numberOfSignatures", "mandatoryKeys", "optionalKeys"],
    "properties": {
        "nonce": {
            "dataType": "uint64",
            "fieldNumber": 1
        },
        "numberOfSignatures": {
            "dataType": "uint32",
            "fieldNumber": 2
        },
        "mandatoryKeys": {
            "type": "array",
            "fieldNumber": 3,
            "items": {
                "dataType": "bytes",
                "length" : 32
            }
        },
        "optionalKeys": {
            "type": "array",
            "fieldNumber": 4,
            "items": {
                "dataType": "bytes",
                "length" : 32
            }
        }
    }
}
```

##### Properties and Default values

In this section, we describe the properties of an auth account and specify their default values.

* <code>[nonce](https://lisk.com/documentation/lisk-sdk/protocol/accounts.html#nonce)</code>: The nonce represents the total number of transactions sent from the account. Each time a new transaction is sent, the nonce is incremented by one. The default value of this property is 0.
* <code>[numberOfSignatures](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0017.md)</code>: The number of private keys that must sign a transaction. This value is greater than 0 if and only if a register multisignature group transaction for this account was included. The default value of this property is 0.
* <code>[mandatoryKeys](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0017.md)</code>: An array of public keys in lexicographical order. The corresponding private keys have to necessarily sign the transaction. A valid public key is 32 bytes long. The default value of this property is an empty array.
* <code>[optionalKeys](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0017.md)</code>: An array of public keys in lexicographical order. The corresponding private keys can optionally sign the transaction. The number of corresponding private keys that have to sign the transaction equals <code>numberOfSignatures</code> minus the length of <code>mandatoryKeys</code>. A valid public key is 32 bytes long. The default value of this property is an empty array.

### Events

#### SignatureGroupRegistered

This event has `typeID = TYPE_ID_MULTISIGNATURE_GROUP_REGISTERED`.
This event is emitted when a multisignature group is registered.

##### Topics

* `address`: The address for which the multisignature group has been registered.

##### Data

```java
multisigRegDataSchema = {
    "type": "object",
    "required": ["numberOfSignatures", "mandatoryKeys", "optionalKeys"],
    "properties": {
        "numberOfSignatures": {
            "dataType": "uint32",
            "fieldNumber": 1
        },
        "mandatoryKeys": {
            "type": "array",
            "items": {
                "dataType": "bytes",
                "length" : 32
            },
            "fieldNumber": 2
        },
        "optionalKeys": {
            "type": "array",
            "items": {
                "dataType": "bytes",
                "length" : 32
            },
            "fieldNumber": 3
        }
    }
}
```

### Commands

#### RegisterMultisignatureGroup

This command allows users to register a multisignature group for the sender account. These specifications supersede those given in [LIP 0017](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0017.md#multisignature-account-registration).

Transactions executing this command have:

* `moduleID = MODULE_ID_AUTH`,
* `commandID = COMMAND_ID_REGISTER_MULTISIGNATURE_GROUP`.

##### Parameters

The `params` property of a multisignature group registration transaction must obey the following schema.

```java
multisigRegParamsSchema = {
    "type": "object",
    "required": ["numberOfSignatures",  "mandatoryKeys", "optionalKeys", "signatures"],
    "properties": {
        "numberOfSignatures": {
            "dataType": "uint32",
            "fieldNumber": 1
        },
        "mandatoryKeys": {
            "type": "array",
            "items": {
                "dataType": "bytes",
                "length" : 32
            },
            "fieldNumber": 2
        },
        "optionalKeys": {
            "type": "array",
            "items": {
                "dataType": "bytes",
                "length" : 32
            },
            "fieldNumber": 3
        },
        "signatures": {
            "type": "array",
            "items": {
                "dataType": "bytes",
                "length" : 64
            },
            "fieldNumber": 4
        }
    }
 }
```

The schema `multisigRegParamsSchema` contains 4 properties. This schema supersedes the one defined in [LIP 0028](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0028.md#multisignature-registration).

1. `numberOfSignatures`: The number of private keys that must sign a transaction.
2. `mandatoryKeys`: An array of public keys. A valid public key is 32 bytes long. Once the account is registered as a multisignature account, every outgoing transaction requires a signature for every public key in `mandatoryKeys`.
3. `optionalKeys`: An array of public keys. A valid public key is 32 bytes long. Once the account is registered as a multisignature account, every outgoing transaction requires some signatures for some public keys in `optionalKeys` (the number of needed signatures depends on the `numberOfSignatures` property and may also be zero).
4. `signatures`: An array of signatures, corresponding to the public keys contained in `mandatoryKeys` and `optionalKeys`. All public keys must have a corresponding signature. The signatures corresponding to `mandatoryKeys` are appended first, followed by those corresponding to `optionalKeys`, where the order of signatures is the same as the order of public keys in the respective array. The message that is signed contains the parameters of the transaction, serialized using the `multisigRegMsgSchema` schema given below.

```java
multisigRegMsgSchema = {
    "type": "object",
    "required": ["address", "nonce", "numberOfSignatures", "mandatoryKeys",  "optionalKeys"],
    "properties": {
        "address": {
            "dataType": "bytes",
            "length" : 20
            "fieldNumber": 1
        },
        "nonce": {
            "dataType": "uint32",
            "fieldNumber": 2
        },
        "numberOfSignatures": {
            "dataType": "uint32",
            "fieldNumber": 3
        },
        "mandatoryKeys": {
            "type": "array",
            "items": {
                "dataType": "bytes",
                "length" : 32
            },
            "fieldNumber": 4
        },
        "optionalKeys": {
            "type": "array",
            "items": {
                "dataType": "bytes",
                "length" : 32
            },
            "fieldNumber": 5
        }
    }
}
```

##### Verification

These specifications supersede those defined in [LIP 0017](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0017.md#multisignature-account-registration).

```python
def verify(trs: Transaction) -> None:
    # Check that a multisignature group is not already registered for this address
    senderAddress = 20-byte address derived from trs.senderPublicKey
    if len(authAccount(senderAddress).mandatoryKeys) > 0 or len(authAccount(senderAddress).mandatoryKeys) > 0:
        raise Exception('Multisignature group already registered for this address.')
    # Mandatory keys are pairwise distinct and ordered lexicographically.
    if trs.params.mandatoryKeys != sorted(set(trs.params.mandatoryKeys)):
        raise Exception('Invalid mandatory keys array.')
    # Optional keys are pairwise distinct and ordered lexicographically.
    if trs.params.optionalKeys != sorted(set(trs.params.optionalKeys)):
        raise Exception('Invalid optional keys array.')
    # Mandatory and optional keys must be disjoint.
    all_keys = trs.params.mandatoryKeys + trs.params.optionalKeys
    if len(all_keys) != len(set(all_keys)):
        raise Exception('Mandatory and optional keys arrays are not disjoint.')
    # Union of mandatory and optional keys must contain between 1 and 64 keys (included).
    if len(all_keys) < 1 or len(all_keys) > 64:
        raise Exception('Invalid length of mandatory and optional keys arrays.')
    # Number of signatures must be an integer between 1 and the total number of public keys.
    if trs.params.numberOfSignatures < 1 or trs.params.numberOfSignatures > len(all_keys):
        raise Exception('Invalid number of signatures.')
    # Number of signatures must not be smaller than the number of mandatory keys.
    if trs.params.numberOfSignatures < len(trs.params.mandatoryKeys):
        raise Exception('Invalid number of signatures.')

    # Verify the signatures 
    message = serialize(
        {
            "address": senderAddress,
            "nonce": trs.nonce,
            "numberOfSignatures": trs.params.numberOfSignatures,
            "mandatoryKeys": trs.params.mandatoryKeys,
            "optionalKeys": trs.params.optionalKeys
        }, 
        multisigRegMsgSchema
    )
    for signature, key in zip(signatures, all_keys):
        verifyMessageSig(key, MULTISIGNATURE_MSG_TAG, networkIdentifier, message, signature)
```

The function `verifyMessageSig` is defined in [LIP 0062](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0062.md#specification) and `networkIdentifier` is the network identifier of the chain.
 schema `multisignatureGroupDataSchema` is 

##### Execution

```python
def execute(trs: Transaction) -> None:
    senderAddress = 20-byte address derived from trs.senderPublicKey
    authAccount(senderAddress).numberOfSignatures = trs.params.numberOfSignatures
    authAccount(senderAddress).mandatoryKeys = trs.params.mandatoryKeys
    authAccount(senderAddress).optionalKeys = trs.params.optionalKeys
    
    emitEvent(
        moduleID = MODULE_ID_AUTH,
        typeID = TYPE_ID_MULTISIGNATURE_GROUP_REGISTERED,
        data = serialize(
            {
                "numberOfSignatures": trs.params.numberOfSignatures,
                "mandatoryKeys": trs.params.mandatoryKeys,
                "optionalKeys": trs.params.optionalKeys
            },
            multisigRegDataSchema
        ),
        topics=[senderAddress]
    )
```

### Protocol Logic for Other Modules

#### getAuthAccount

This function is used to retrieve information about an auth account.

##### Parameters

* `address`: A 20 bytes value identifying the auth account.

##### Returns

This function returns `authAccount(address)`. If there is no entry corresponding to `address`, it returns an empty object.

### Endpoints for Off-Chain Services

#### getAuthAccount

This function is used to retrieve information about an auth account.

##### Parameters

* `address`: A 20 bytes value identifying the auth account.

##### Returns

This function returns `authAccount(address)`. If there is no auth account corresponding to `address`, it returns an empty object.

#### verifySignatures

This function verifies the signatures of a given transaction `trs`, including transactions from  multisignature accounts.

##### Parameters

* `trs`: A transaction object.

##### Returns

This function returns `true` if the transaction object contains a valid signature, `false` otherwise, as specified in [LIP 0017](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0017.md#transaction-creation-and-verification).

#### verifyNonce

This function verifies the nonce of a given transaction `trs` and returns a boolean value.

##### Parameters

* `trs`: A transaction object.

##### Returns

This function returns `true` if the transaction object contains a valid nonce, `false` otherwise. This is done using the `transactionVerification(trs)` function defined [below](#transaction-verification).

### Genesis Block Processing

#### Genesis State Initialization

During the genesis state initialization stage, the following steps are executed. If any step fails, the block is discarded and has no further effect.

Let `genesisBlockAssetBytes` be the `data` bytes included in the block assets for the Auth module and let `genesisBlockAssetObject` be the deserialization of `genesisBlockAssetBytes` according to the `genesisAuthStoreSchema` schema, given below. 

* For each entry `entry` in `genesisBlockAssetObject.authDataSubstore`, let `address = entry.address` and `authAccount = entry.authAccount` and check the following: 
  * Each entry has a different `address` and all `address` have length 20.
  * If `authAccount.numberOfSignatures` is not 0 (a multisignature account), check that the rules listed in [LIP 0017](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0017.md#multisignature-account-registration) are respected. In particular:
    * The keys in the `authAccount.mandatoryKeys` array have length 32, are pairwise distinct and in lexicographical order. The array may be empty.
    * The keys in the `authAccount.optionalKeys` array have length 32, are pairwise distinct and in lexicographical order. The array may be empty.
    * The arrays `authAccount.mandatoryKeys` and `authAccount.optionalKeys` are disjoint; their union has at least one element and at most 64 elements.
    * `authAccount.numberOfSignatures` is an integer between 1 and the total number of public keys of the account (sum of the length of `authAccount.mandatoryKeys` and `authAccount.optionalKeys`).
    * `authAccount.numberOfSignatures` is not smaller than the length of `authAccount.mandatoryKeys`.
* Finally, for each entry `entry` in `genesisBlockAssetObject.authDataSubstore`, create a corresponding entry in the auth data substore with `storeKey = entry.address` and `storeValue = entry.authAccount`.

```java
genesisAuthStoreSchema = {
  "type": "object",
  "required": ["authDataSubstore"],
  "properties": {
    "authDataSubstore": {
      "type": "array",
      "fieldNumber": 1,
      "items": {
        "type": "object",
        "required": ["address", "authAccount"],
        "properties": {
          "address": {
            "dataType": "bytes",
            "length": 20,
            "fieldNumber": 1
          },
          "authAccount": {
            "type": "object",
            "fieldNumber": 2,
            "required": [
              "nonce",
              "numberOfSignatures",
              "mandatoryKeys",
              "optionalKeys"
            ],
            "properties": {
              "nonce": {
                "dataType": "uint64",
                "fieldNumber": 1
              },
              "numberOfSignatures": {
                "dataType": "uint32",
                "fieldNumber": 2
              },
              "mandatoryKeys": {
                "type": "array",
                "fieldNumber": 3,
                "items": {
                  "dataType": "bytes",
                  "length": 32,
                }
              },
              "optionalKeys": {
                "type": "array",
                "fieldNumber": 4,
                "items": {
                  "dataType": "bytes",
                  "length": 32,
                }
              }
            }
          }
        }
      }
    }
  }
}
```

#### Genesis State Finalization

The Auth module does not execute any logic during the genesis state finalization.

### Block Processing

#### Transaction Verification

As part of the verification of a transaction `trs`, check that the transaction nonce is equal to the account nonce or to 0 if the account does not exist. If the checks fail the transaction is invalid and the whole block is discarded.

```python
def transactionVerification(trs: Transaction) -> None:
  senderAddress = 20-byte address derived from trs.senderPublicKey
  if there is no entry in the in the auth data substore with storeKey == senderAddress and trs.nonce != 0:
    raise Exception('Invalid transaction nonce.')
  elif trs.nonce != authAccount(senderAddress).nonce
    raise Exception('Invalid transaction nonce.')
```

Notice that a transaction in the transaction pool with a nonce greater than the account nonce is considered "pending" rather than invalid, since it could become valid in the future.

* Check the signatures property of the transaction [as explained in LIP 0017](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0017.md#signatures-replaces-signature) using `authAccount(address)`, where `address` is the address corresponding to `trs.senderPublicKey`.

#### Before Command Execution

Before the command referenced in a transaction `trs` is executed, an auth account is created if no account exists for the sender address.

```python
def beforeCommandExecution(trs: Transaction) -> None:
  senderAddress = 20-byte address derived from trs.senderPublicKey
  if there is no entry in the in the auth data substore with storeKey == senderAddress:
    create an entry in the auth data substore with storeKey = senderAddress, initialized to default values
```

#### After Command Execution

After the command referenced in a transaction `trs` is executed, the account nonce is incremented.

```python
def afterCommandExecution(trs: Transaction) -> None:
  let senderAddress be the address corresponding to trs.senderPublicKey
  authAccount(senderAddress).nonce += 1
```

## Backwards Compatibility

This LIP defines a new storage interface for the Auth module, which in turn will become part of the state tree and will be authenticated by the state root. An existing chain including the Auth module will need to perform a hardfork.
