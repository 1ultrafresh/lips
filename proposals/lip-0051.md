```
LIP: 0051
Title: Define state and state transitions of Token module
Author: Maxime Gagnebin <maxime.gagnebin@lightcurve.io>
Discussions-To: https://research.lisk.com/t/define-state-and-state-transitions-of-token-module/295
Status: Draft
Type: Standards Track
Created: 2021-05-21
Updated: 2022-01-10
```

## Abstract

This LIP introduces a Token module to be used in the Lisk ecosystem for minting, burning, and transferring tokens. This module allows any chain in the ecosystem to handle and transfer tokens in a coherent, secure, and controlled manner. In this LIP, the tokens handled are fungible.

## Copyright

This LIP is licensed under the [Creative Commons Zero 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/).

## Motivation

The Token module is composed of a state store definition used to store tokens in the state. To modify this store, we propose two commands: a token transfer command and a cross-chain token transfer command; as well as multiple functions to be used by other modules.

Interactions between custom modules and the Token module should only happen following the specified functions. Interacting with the token store via those functions allows sidechain developers to create custom modules and custom behavior without needing to ensure and test that all rules of the Token module are followed.

With the proposed interoperability solution for the Lisk ecosystem, we anticipate that multiple chains will create and distribute custom tokens. Those tokens can be used for a wide variety of reasons which are the choice of the sidechain developer.

## Rationale

### Technical Glossary

* **Native chain:** With regards to a token, this is the chain where the token was minted.
* **Native tokens:** With regards to a chain, all tokens minted on this chain.
* **Foreign chain:** With regards to a token, all chains other than the native chain.

### Token Identification and Interoperability

To identify tokens in the Lisk ecosystem, we introduce token identifiers in this proposal. An identifier will be unique among all tokens in the ecosystem. It is built from the [chain ID][research:chain-registration] of the chain minting the token and a local identifier, an integer chosen when the token is minted. The local identifier allows chains to define multiple custom tokens, each identified by their respective local ID. For example, a decentralized exchange could have a governance token (distributed in the genesis block) and a liquidity token (distributed to liquidity providers).

In particular, the LSK token is native to the Lisk mainchain which has `chainID = 1`, it is also the first (and only) token of this chain and has `localID = 0`. This entails that the LSK token ID is `(1,0)`. Token identifiers in this LIP are written as a dictionary `{"chainID": 1, "localID": 0}` (for example for the LSK token). Other document could also choose to represent them as a tuple, the LSK ID could then be written as `(1,0)`.

#### Supported Tokens

All chains are allowed to select which tokens their protocol supports. Supporting a token only implies that users of the chain can hold those tokens and handle them as specified in this LIP. It does not mean that the chain implements custom logic associated with those tokens.

The choice of supported tokens must abide by two rules: all chains must support their native tokens and all chains must support the LSK token. The supported tokens can be specified as part of the initial configuration of the Token module at the chain creation. For example:

* A decentralized exchange could support all tokens.
* A chain with a specific use case and no native token could only support the LSK token.
* A chain with a specific use case and with a native token might only support the LSK token and their native token.
* A gambling chain might support their native token, the LSK token and tokens from a selected group of oracle chains.

When receiving unsupported tokens from a cross-chain transfer, chains should return those tokens to the sending chain if the message fee was sufficient. The threshold on the message fee to return unsupported tokens is chosen to be the same as the interoperability threshold for [returning CCMs][research:ccm] for other errors. This threshold is set to be equal to the Lisk mainchain minimum fee.

Lastly, note that modifying the list of supported tokens would result in a fork of the chain. For this reason, the default behavior for Lisk sidechains would be to support all tokens.

### Cross-chain Token Transfer

To allow cross-chain transfers of tokens, we define a specific command which makes use of the [Interoperability module][research:base-interoperability] and creates a [cross-chain message][research:ccm] with the relevant information. When sending cross-chain tokens, it is crucial that every chain can correctly maintain escrow amounts of its native tokens across the ecosystem. In this way, the total supply of a token can never be increased by a foreign chain as the native chain only accepts as many tokens from a foreign chain as have been sent to it before.

#### Transfer To and From the Native Chain

These specifications only allow tokens to be transferred to and from their native chain. In particular, this means that a token minted on chain A cannot be transferred directly from chain B to chain C. This is required to allow the native chain to maintain correct escrowed amounts. The alternative would be to allow such transfer and require an additional message to be sent to the native chain to acknowledge the transfer. However the correctness of the escrowed amounts would rely on the processing of this additional information. Network delays could mean that this is only processed much later and that in the meantime users have been tricked into accepting tokens not backed by escrow.

### Protocol Logic for Other Modules

The functions below are the exposed methods of the Token module. For the Token module those functions are designed to allow a wide range of use cases while avoiding unexpected behaviors such as unwanted minting or unlocking of tokens.

#### mint

This function allows a chain to mint a specified amount of native tokens. This function will increase the balance by the specified amount in the specified user substore and at the same time, increase the corresponding total token supply.

#### burn

This function allows a chain to destroy a specified amount of native tokens. When burning tokens, this function will remove the specified amount of tokens from the user substore and at the same time decrease the total supply corresponding to the token.

#### transfer

This function allows a chain to transfer tokens. When transferring tokens, this function will remove the tokens from the sender and add them to the recipient.

#### transferCrossChain

This function is used if a custom module needs to send tokens to another chain. It ensures that all amounts are correctly validated and that tokens are escrowed if necessary.

#### lock

This function is used to lock tokens held by a user. Locking tokens is done "module wise", i.e., when locking tokens a `moduleID` has to be specified. This allows locked tokens to be managed more securely. For example, if a token is locked in a DPoS module, then there is no risk that a bug in a custom HTLC module would unlock those tokens.

#### unlock

This function is used to unlock tokens previously locked. As for locking, the corresponding module ID needs to be specified in order to unlock the correct tokens. Notice that there is no protocol rule restricting different modules from unlocking tokens locked with a given `moduleID`, it is a protection allowing well written code to be more secure.

#### beforeSendCCM

This function is called by the Interoperability module before sending cross-chain messages. It handles deducting the message fee from the account of the message sender. It should not be called by any other module.

#### beforeApplyCCM

This function is called by the Interoperability module before applying cross-chain messages. It handles crediting the message fee to the account of the cross-chain update sender. It should not be called by any other module.

#### beforeRecoverCCM

This function is called by the Interoperability module before recovering cross-chain messages. It handles crediting the message fee to the account of the sender of the recovery command. It should not be called by any other module.

#### recover

This function is called by the interoperability module whenever [state recovery transaction][research:sidechain-recovery] for the Token module is executed. The amount of native tokens stored in the terminated chain can therefore be credited again to the user on the native chain. It should not be called by any other module.

#### Use of Protocol Logics by Other Modules

As of writing this proposal, other modules exist in the Lisk protocol that make use of tokens. Those uses should be updated to call functions implemented by the Token module as defined in this proposal. This guarantees that those modules will not trigger potentially improper state changes. For example:

* The voting process should use the `lock` and `unlock` function to lock and unlock voted tokens.
* Block rewards should be assigned using the `mint` function.
* The fee handling should use the `transfer` function to transfer the fee from the transaction sender to the block forger and, on the Lisk mainchain, the `burn` function to burn the minimum part of the fee.

## Specification

### Constants and Notations

The following constants are used throughout the document:

| Name                                 | Type    | Value                        |
|--------------------------------------|---------|------------------------------|
| **Interoperability Constants**       |         |                              |
| `MAINCHAIN_ID`                       | uint32  | 1                            |
| `MIN_RETURN_FEE`                     | uint64  | 1000                         |
| **Token Module Constants**           |         |                              |
| `MODULE_ID_TOKEN`                    | uint32  | TBD                          |
| `COMMAND_ID_TRANSFER`                | uint32  | 0                            |
| `COMMAND_ID_CROSS_CHAIN_TRANSFER`    | uint32  | 1                            |
| `CROSS_CHAIN_COMMAND_ID_TRANSFER`    | uint32  | 0                            |
| `CROSS_CHAIN_COMMAND_ID_FORWARD`     | uint32  | 1                            |
| `CCM_STATUS_OK`                      | uint32  | 0                            |
| `CCM_STATUS_TOKEN_NOT_SUPPORTED`     | uint32  | 64                           |
| `CCM_STATUS_PROTOCOL_VIOLATION`      | uint32  | 65                           |
| `CCM_STATUS_MIN_BALANCE_NOT_REACHED` | uint32  | 66                           |
| `MIN_BALANCE`                        | uint64  | 5000000                      |
| `CHAIN_ID_ALIAS_NATIVE`              | uint32  | 0                            |
| `LOCAL_ID_LSK`                       | uint32  | 0                            |
| `TOKEN_ID_LSK`                       | object  | {"chainID": 1, "localID": 0} |
| `TOKEN_ID_LSK_MAINCHAIN`             | object  | {"chainID": 0, "localID": 0} |
| **Token Store Constants**            |         |                              |
| `STORE_PREFIX_USER`                  | bytes   | 0x 00 00                     |
| `STORE_PREFIX_SUPPLY`                | bytes   | 0x 80 00                     |
| `STORE_PREFIX_ESCROW`                | bytes   | 0x c0 00                     |
| `STORE_PREFIX_AVAILABLE_LOCAL_ID`    | bytes   | 0x d0 00                     |
| **General Constants**                |         |                              |
| `ADDRESS_LENGTH`                     | uint32  | 20                           |
| `MAX_DATA_LENGTH`                    | uint32  | 64                           |
| `EMPTY_BYTES`                        | bytes   | ""                           |

#### uint32be Function

The function `uint32be(x)` returns the big endian uint32 serialization of an integer `x`, with `0 <= x < 2^32`. This serialization is always 4 bytes long.

#### Logic from Other Modules

Calling a function `fct` implemented in the [Interoperability module][research:base-interoperability] is represented by `interoperability.fct(required inputs)`.

### Token Identification

All tokens in the ecosystem are identified by a pair of non-negative integers `(chainID, localID)`, both strictly less than 2^32. The first element of the pair, `chainID`, is the chain ID of the chain that minted the token (an integer, as specified in the ["Introduce chain registration mechanism" LIP][research:chain-registration]) and the second element, `localID`, is an integer specified when the token is minted.

In this LIP, the token identifier is written as a dictionary of 2 elements `{"chainID": chainID, "localID": localID}`. This is for example used in all input formats for the module's exposed functions. This choice follows a potential way the module could be implemented in JavaScript, the same behavior could be implemented with a named tuple in Python. This allows the exposed function interfaces to be simple and uniform.

#### Token ID and Native Tokens

Tokens on their native chain are identified by the pair `{"chainID": CHAIN_ID_ALIAS_NATIVE, "localID": localID}`. The same tokens in other chains would be identified by the pair `{"chainID": nativeChainID, "localID": localID}`.

In all sidechains, the LSK token is identified by the pair `{"chainID": 1, "localID": 0}`, i.e., `chainID = MAINCHAIN_ID = 1` and `localID = 0`. This is in contrast with the LSK ID on mainchain which is `{"chainID": 0, "localID": 0}`.

#### Supported Tokens

The Token module contains a function used when receiving cross-chain messages to assert the support for non-native tokens. It should return a boolean, depending on the configuration of the Token module. For the rest of this LIP, this function is written as `tokenSupported(tokenID)`. It must satisfy the condition below:

* `tokenSupported({"chainID": MAINCHAIN_ID, "localID":  LOCAL_ID_LSK}) = True`. This corresponds to the token ID of the LSK token.

Further, on the Lisk mainchain, the LSK token is the only supported token (no tokens with different chain ID are supported).

### Token Module Store

The Token module store is separated in three parts, the supply substore, the escrow substore and the user substore.

#### Supply Substore

The Token module store contains an entry dedicated to storing information about the total supply of native tokens. The substore contains entries with:

* The store prefix is set to `STORE_PREFIX_SUPPLY`.
* Each store key is a serialized local ID: `uint32be(localID)`.
* Each store value is the serialization of an object following `supplyStoreSchema`.

```java
supplyStoreSchema = {
    "type": "object",
    "required": ["totalSupply"],
    "properties": {
        "totalSupply": {
            "dataType": "uint64",
            "fieldNumber": 1
        }
    }
}
```

The default value for this substore is `{"totalSupply": 0}` serialized using `supplyStoreSchema`.

#### Available Local ID Substore

The Token module store contains an entry dedicated to storing information about the available local IDs:

* The store prefix is set to `STORE_PREFIX_AVAILABLE_LOCAL_ID`.
* Each store key is the empty bytes.
* Each store value is the serialization of an object following `availableLocalIDStoreSchema`.

```java
availableLocalIDStoreSchema = {
    "type": "object",
    "required": ["nextAvailableLocalID"],
    "properties": {
        "nextAvailableLocalID": {
            "dataType": "uint32",
            "fieldNumber": 1
        }
    }
}
```

The default value for this substore is `{"nextAvailableLocalID": 0}` serialized using `availableLocalIDStoreSchema`.

#### Escrow Substore

The Token module store contains an entry dedicated to storing information about native tokens which have been sent to another chain. The state contains an entry with:

* The store prefix is set to `STORE_PREFIX_ESCROW`.
* Each store key is the identifier of the chain to which the tokens are escrowed, and the local ID of the escrowed token: `uint32be(escrowedChainID)||uint32be(tokenLocalID)`.
* Each store value is the serialization of an object following `escrowStoreSchema`.

```java
escrowStoreSchema = {
    "type": "object",
   "required": ["amount"],
    "properties": {
        "amount" : {
            "dataType": "uint64",
            "fieldNumber": 1
        }
    }
}
```

If any state transition would reduce the `amount` property of an entry to zero, this entry is removed from the escrow substore.

If any state transition would increase the `amount` property of a non-existent substore entry, this entry is created.

#### User Substore

The Token module store contains entries dedicated to storing the balances of users for a given `address` and `tokenID`. The substore contains entries with:

* The store prefix is set to `STORE_PREFIX_USER`
* Each store key is a 20-byte address, and a token ID: `address || uint32be(tokenID.chainID) || uint32be(tokenID.localID) `
* Each store value is the serialization of an object following `userStoreSchema`.

```java
userStoreSchema = {
    "type": "object",
    "required": ["availableBalance", "lockedBalances"],
    "properties": {
        "availableBalance": {
            "dataType": "uint64",
            "fieldNumber": 1
        },
        "lockedBalances": {
            "type": "array",
            "fieldNumber": 2,
            "items": {
                "type": "object",
                "required":[ "moduleID", "amount" ],
                "properties": {
                    "moduleID": {
                        "dataType":"uint32",
                        "fieldNumber": 1
                    },
                    "amount": {
                        "dataType": "uint64",
                        "fieldNumber": 2
                    }
                }
            }
        }
    }
}
```

In the above object, `lockedBalances` is always kept ordered by ascending order of `moduleID`. This guarantees that serialization is done consistently across nodes maintaining the chain.

The `lockedBalances` array contains only elements with non-zero amounts. If any state transition would reduce the `amount` property of an element to zero, this element is removed from the array.

When, after any state transition, all amounts in a user substore entry (available and locked) are zero the state entry is removed.

If any state transition would increase the `availableBalance` property of a non-existent store entry, this entry is created following `userStoreSchema` with the available balance set accordingly.

#### Store Notation

For the rest of this proposal:

* Let `userStore(address, tokenID)` be the user substore entry with store key `address || uint32be(tokenID.chainID) || uint32be(tokenID.localID)`.
  * Let `availableBalance(address, tokenID)` be the `availableBalance` property of `userStore(address, tokenID)`. If the corresponding store entry does not exist, we assume that the available balance is 0.
  * Let `lockedAmount(address, moduleID, tokenID)` be the amount corresponding to the given `moduleID` in the `lockedBalances` array of `userStore(address, tokenID)`. If the corresponding store entry does not exist, we assume that the amount is 0.
* Let `escrowStore(chainID)` be the escrow substore entry with store key `uint32be(chainID)`.
  * Let `escrowAmount(chainID, localID)` be the amount corresponding to the given `localID` in the `escrowedTokens` array of `escrowStore(chainID)`. If the corresponding store entry does not exist, we assume that the amount is 0.
* Let `supplyStore(localID)` be the supply substore entry with store key `uint32be(localID)`.
  * Let `totalSupply(localID)` be the `totalSupply` property stored in `supplyStore(localID)`.
* Let `nextAvailableLocalID` be the `nextAvailableLocalID` property of the entry of the available local ID substore.

### Commands

The module provides the following commands to modify token entries.

#### Token Transfer

Transactions executing this command have:

* `moduleID = MODULE_ID_TOKEN`
* `commandID  = COMMAND_ID_TRANSFER`

##### Parameters Schema

The `params` property of token transfer transactions follows the schema `transferParams`.

```java
transferParams = {
    "type": "object",
    "required": [
        "tokenID",
        "amount",
        "recipientAddress",
        "data"
    ],
    "properties": {
        "tokenID": {
            "type": "object",
            "fieldNumber": 1,
            "required": ["chainID", "localID"],
            "properties": {
                "chainID": {
                    "dataType": "uint32",
                    "fieldNumber": 1
                },
                "localID": {
                    "dataType": "uint32",
                    "fieldNumber": 2
                }
            }
        },
        "amount": {
            "dataType": "uint64",
            "fieldNumber": 2
        },
        "recipientAddress": {
            "dataType": "bytes",
            "fieldNumber": 3
        },
        "data": {
            "dataType": "string",
            "fieldNumber": 4
        }
    }
}
```

##### Parameters Validity

The `params` property of a token transfer transaction is valid if:

* `recipientAddress` is a byte array of length `ADDRESS_LENGTH`.
* `data` has length less than or equal to `MAX_DATA_LENGTH`.

##### Execution

When executing a token transfer transaction `trs`, the logic below is followed:

```python
derive senderAddress from trs.senderPublicKey
let tokenID, recipientAddress, amount given by trs.params

if availableBalance(senderAddress, tokenID) < amount:
    transaction execution fails

availableBalance(senderAddress, tokenID) -= amount
availableBalance(recipientAddress, tokenID) += amount
```

#### Cross-chain Token Transfer

Transactions executing this command have:

* `moduleID = MODULE_ID_TOKEN`
* `commandID  = COMMAND_ID_CROSS_CHAIN_TRANSFER`

##### Parameters Schema

The `params` property of cross-chain token transfer transactions follows the schema `crossChainTransferParams`.

```java
crossChainTransferParams = {
    "type": "object",
    "required": [
        "tokenID",
        "amount",
        "receivingChainID",
        "recipientAddress",
        "data",
        "messageFee"
    ],
    "properties": {
        "tokenID": {
            "type": "object",
            "fieldNumber": 1,
            "required": ["chainID", "localID"],
            "properties": {
                "chainID": {
                    "dataType": "uint32",
                    "fieldNumber": 1
                },
                "localID": {
                    "dataType": "uint32",
                    "fieldNumber": 2
                }
            }
        },
        "amount": {
            "dataType": "uint64",
            "fieldNumber": 2
        },
        "receivingChainID": {
            "dataType": "uint32",
            "fieldNumber": 3
        },
        "recipientAddress": {
            "dataType": "bytes",
            "fieldNumber": 4
        },
        "data": {
            "dataType": "string",
            "fieldNumber": 5
        },
        "messageFee": {
            "dataType": "uint64",
            "fieldNumber": 6
        }
    }
}
```

##### Parameters Validity

The `params` property of a cross-chain token transfer transaction is valid if:

* `recipientAddress` is a byte array of length `ADDRESS_LENGTH`.
* `data` has length less than or equal to `MAX_DATA_LENGTH`.
* `tokenID.chainID` is either `CHAIN_ID_ALIAS_NATIVE`, `MAINCHAIN_ID` or `receivingChainID`.

##### Execution

When executing a cross-chain token transfer transaction `trs`, the following is done:

* Derive `senderAddress` from `trs.senderPublicKey`.
* Execute the logic defined by:

```python
transferCrossChain(senderAddress,
                   trs.params.receivingChainID,
                   trs.params.recipientAddress,
                   trs.params.tokenID,
                   trs.params.amount,
                   trs.params.messageFee,
                   trs.params.data)
```

### Cross-chain Commands

#### Cross-chain Token Transfer Messages

Cross-chain messages executing this cross-chain command have:

* `moduleID = MODULE_ID_TOKEN`
* `crossChainCommandID  = CROSS_CHAIN_COMMAND_ID_TRANSFER`

##### CCM Parameters

The `params` property of cross-chain token transfer messages follows the schema `crossChainTransferMessageParams`.

```java
crossChainTransferMessageParams = {
    "type": "object",
    "required": [
        "tokenID",
        "amount" ,   
        "senderAddress",
        "recipientAddress",
        "data"
    ],
    "properties": {
        "tokenID": {
            "type": "object",
            "fieldNumber": 1,
            "required": ["chainID", "localID"],
            "properties": {
                "chainID": {
                    "dataType": "uint32",
                    "fieldNumber": 1
                },
                "localID": {
                    "dataType": "uint32",
                    "fieldNumber": 2
                }
            }
        },
        "amount": {
            "dataType": "uint64",
            "fieldNumber": 2
        },
        "senderAddress": {
            "dataType": "bytes",
            "fieldNumber": 3
        },
        "recipientAddress": {
            "dataType": "bytes",
            "fieldNumber": 4
        },
        "data": {
            "dataType": "string",
            "fieldNumber": 5
        }
    }
}
```

##### Execution

When executing a cross-chain token transfer message `ccm`, the logic below is followed.

```python
tokenID = ccm.params.tokenID
tokenChainID = tokenID.ChainID
tokenLocalID = tokenID.LocalID
amount = ccm.params.amount
recipientAddress = ccm.params.recipientAddress
senderAddress = ccm.params.senderAddress
sendingChainID = ccm.sendingChainID
ownChainID = interoperability.getOwnChainAccount().ID

# Token should only be sent to and from their native chains
if (tokenChainID not in [ownChainID, sendingChainID]
    or length(senderAddress) != ADDRESS_LENGTH
    or length(recipientAddress) != ADDRESS_LENGTH
    or length(ccm.params.data) > MAX_DATA_LENGTH
    or (tokenChainID == ownChainID
        and escrowAmount(sendingChainID, tokenLocalID) < amount)):
    if (ccm.status == CCM_STATUS_OK
        and ccm.fee >= MIN_RETURN_FEE * length(ccm)):
        interoperability.error(ccm, CCM_STATUS_PROTOCOL_VIOLATION)
    interoperability.terminateChain(sendingChainID)
    stop ccm execution

if tokenChainID == ownChainID:
    escrowAmount(sendingChainID, tokenLocalID) -= amount
    localTokenID = {"chainID": CHAIN_ID_ALIAS_NATIVE, "localID": tokenLocalID}

    if ccm.status == CCM_STATUS_OK:
        availableBalance(recipientAddress, localTokenID) += amount
    else:
        availableBalance(senderAddress, localTokenID) += amount

else: # tokenChainID != ownChainID:
    # Return any non-supported tokens with enough fee
    if tokenSupported(tokenID) == False:
        if (ccm.fee >= MIN_RETURN_FEE*length(ccm)
            and ccm.status == CCM_STATUS_OK):
            interoperability.error(ccm, CCM_STATUS_TOKEN_NOT_SUPPORTED)
        stop ccm execution
    if ccm.status == CCM_STATUS_OK:
        availableBalance(recipientAddress, tokenID) += amount
    else:
        availableBalance(senderAddress, tokenID) += amount        
```

#### Cross-chain Token Forward Messages

Cross-chain messages executing this cross-chain command have:

* `moduleID = MODULE_ID_TOKEN`
* `crossChainCommandID  = CROSS_CHAIN_COMMAND_ID_FORWARD`

##### CCM Parameters

The `params` property of cross-chain token forward messages follows the schema `crossChainForwardMessageParams`.

```java
crossChainForwardMessageParams = {
    "type": "object",
    "required": [
        "tokenID",  
        "amount" ,   
        "senderAddress",
        "forwardToChainID",
        "recipientAddress",
        "data",
        "forwardedMessageFee"
    ],
    "properties": {
        "tokenID": {
            "type": "object",
            "fieldNumber": 1,
            "required": ["chainID", "localID"],
            "properties": {
                "chainID": {
                    "dataType": "uint32",
                    "fieldNumber": 1
                },
                "localID": {
                    "dataType": "uint32",
                    "fieldNumber": 2
                }
            }
        },
        "amount": {
            "dataType": "uint64",
            "fieldNumber": 2
        },
        "senderAddress": {
            "dataType": "bytes",
            "fieldNumber": 3
        },
        "forwardToChainID": {
            "dataType": "bytes",
            "fieldNumber": 4
        },      
        "recipientAddress": {
            "dataType": "bytes",
            "fieldNumber": 5
        },
        "data": {
            "dataType": "string",
            "fieldNumber": 6
        },
        "forwardedMessageFee": {
            "dataType": "uint64",
            "fieldNumber": 7
        }
    }
}
```

##### Execution

When executing a cross-chain token forward message, the logic below is followed.

```python
sendingChainID = ccm.sendingChainID
tokenID = ccm.params.tokenID
amount = ccm.params.amount
forwardToChainID = ccm.params.forwardToChainID
recipientAddress = ccm.params.recipientAddress
senderAddress = ccm.params.senderAddress
data = ccm.params.data
forwardedMessageFee = ccm.params.forwardedMessageFee
ownChainID = interoperability.getOwnChainAccount().ID

if (length(senderAddress) != ADDRESS_LENGTH
    or length(recipientAddress) != ADDRESS_LENGTH
    or length(ccm.params.data) > MAX_DATA_LENGTH):
    if ccm.status == CCM_STATUS_OK:
        interoperability.error(ccm, CCM_STATUS_PROTOCOL_VIOLATION)
    interoperability.terminateChain(sendingChainID)
    stop ccm execution

if ccm.status != CCM_STATUS_OK:
    if sendingChainID == tokenID.chainID:
        # Credit the sender with the returned tokens
        availableBalance(senderAddress, tokenID) += amount + forwardedMessageFee
    else:
        # This should not happen, the sending chain modified the Token module
        # the message is malicious and no tokens should be credited
        interoperability.terminateChain(sendingChainID)
    stop ccm execution

if (tokenID.chainID != ownChainID
    or escrowAmount(sendingChainID, tokenID.localID) < amount + forwardedMessageFee):
    if ccm.status == CCM_STATUS_OK:
        interoperability.error(ccm, CCM_STATUS_PROTOCOL_VIOLATION)
    interoperability.terminateChain(sendingChainID)
    stop ccm execution

escrowAmount(sendingChainID, tokenID.localID) -= amount + forwardedMessageFee
localTokenID = {"chainID": CHAIN_ID_ALIAS_NATIVE, "localID": tokenID.localID}
availableBalance(senderAddress, localTokenID) += amount + forwardedMessageFee

messageParams: {  
    "tokenID": tokenID,
    "amount": amount,
    "senderAddress": senderAddress,
    "recipientAddress": recipientAddress,
    "data": data
}

serializedParams = serialization of messageParams
                   following crossChainTransferMessageParams


if interoperability.send(senderAddress,
                         MODULE_ID_TOKEN,
                         CROSS_CHAIN_COMMAND_ID_TRANSFER,
                         forwardToChainID,
                         forwardedMessageFee,
                         CCM_STATUS_OK,
                         serializedParams):
    availableBalance(senderAddress, localTokenID) -= amount
    # Notice that the forwardedMessageFee was deducted by the send function
```

### Genesis Block Processing

#### Genesis Assets Schema

```java
genesisTokenStoreSchema = {
    "type": "object",
    "required": [
        "userSubstore",
        "supplySubstore",
        "escrowSubstore",
        "availableLocalIDSubstore",
        "terminatedEscrowSubstore"
    ],
    "properties": {
        "userSubstore": {
            "type": "array",
            "fieldNumber": 1,
            "items": {
                "type": "object",
                "required": [
                    "address",
                    "tokenID",
                    "availableBalance",
                    "lockedBalances"
                ],
                "properties": {
                    "address": {
                        "dataType": "bytes",
                        "fieldNumber": 1
                    },
                    "tokenID": {
                        "type": "object",
                        "fieldNumber": 2,
                        "required": ["chainID", "localID"],
                        "properties": {
                            "chainID": {
                                "dataType": "uint32",
                                "fieldNumber": 1
                            },
                            "localID": {
                                "dataType": "uint32",
                                "fieldNumber": 2
                            }
                        }
                    },
                    "availableBalance": {
                        "dataType": "uint64",
                        "fieldNumber": 3
                    },
                    "lockedBalances": {
                        "type": "array",
                        "fieldNumber": 4,
                        "items": {
                            "type": "object",
                            "required": ["moduleID", "amount"],
                            "properties": {
                                "moduleID": {
                                    "dataType": "uint32",
                                    "fieldNumber": 1
                                },
                                "amount": {
                                    "dataType": "uint64",
                                    "fieldNumber": 2
                                }
                            }
                        }
                    }
                }
            }
        },
        "supplySubstore": {
            "type": "array",
            "fieldNumber": 2,
            "items": {
                "type": "object",
                "required": ["localID", "totalSupply"],
                "properties": {
                    "localID": {
                        "dataType": "uint32",
                        "fieldNumber": 1
                    },
                    "totalSupply": {
                        "dataType": "uint64",
                        "fieldNumber": 1
                    }
                }
            }
        },
        "escrowSubstore": {
            "type": "array",
            "fieldNumber": 3,
            "items": {
                "type": "object",
                "required": ["escrowChainID", "localID", "amount"],
                "properties": {
                    "escrowChainID": {
                        "dataType": "bytes",
                        "fieldNumber": 1
                    },
                    "localID": {
                        "dataType": "uint32",
                        "fieldNumber": 2
                    },
                    "amount": {
                        "dataType": "uint64",
                        "fieldNumber": 3
                    }
                }
            }
        },
        "availableLocalIDSubstore": {
            "type": "object",
            "required": ["nextAvailableLocalID"],
            "fieldNumber": 4,
            "properties": : {
                "nextAvailableLocalID": {
                    "dataType": "uint32",
                    "fieldNumber": 1
                }
            }
        },
        "terminatedEscrowSubstore": {
            "type": "array",
            "fieldNumber": 5,
            "items": {
                "type": "uint32"
            }
        }
    }
}
```

#### Genesis State Initialization

During the genesis state initialization stage, the following steps are executed. If any step fails, the block is discarded and has no further effect.

Let `genesisBlockAssetBytes` be the `data` bytes included in the block assets for the Token module and let `genesisBlockAssetObject` be the deserialization of `genesisBlockAssetBytes` according to the `genesisTokenStoreSchema` schema, given above.

* Initial checks on the properties of `genesisBlockAssetObject`:
  * Across all elements of the `userSubstore` array, all `address` values must have length `ADDRESS_LENGTH`.
  * Across all elements of the `userSubstore` array, the pairs `address, tokenID` must be unique (each pair appears at most once, though a given address can appear multiple times with different token IDs).
  * The `userSubstore` array must be in lexicographical order of `address`. For a given `address`, the entries must be in ascending order of `tokenID.chainID`. For a given `address` and `tokenID.chainID`, the entries must be in ascending order of `tokenID.localID`.
  * For each `address, tokenID` pair:
    * The values used as `moduleID` in the `lockedBalances` array must be unique.
    * The `lockedBalances` array must be in asscending order of `moduleID`.
    * All elements of the `lockedBalances` array must have `amount != 0`.
    * Either `availableBalance != 0` or `lockedBalances != []` must be true, i.e.: the entry must contain some tokens.
  * Across all element of the `supplySubstore` array, all values given for `localID` must be unique.
  * The `supplySubstore` array must be in ascending order of `localID`.
  * Across all elements of the `escrowSubstore` array, the pairs `escrowChainID, localID` must be unique (each pair appears at most once).
  * The `escrowSubstore` array must be in ascending order of `escrowChainID`. For a given `escrowChainID`, the entries must be in ascending order of `localID`.
  * In the `terminatedEscrowSubstore` array, each element must be unique (appears at most once).
  * The `terminatedEscrowSubstore` array must be in ascending order.

* For each entry `userEntry` in `genesisBlockAssetObject.userSubstore`, create an entry in the user substore with:
  ```python
  storeKey = userEntry.address || uint32be(userEntry.tokenID.chainID) || uint32be(userEntry.tokenID.localID)
  storeValue = {"availableBalance": userEntry.availableBalance,
                "lockedBalances": [{"moduleID": lockedBalance.moduleID,
                                    "amount": lockedBalance.amount
                                   } for each lockedBalance in userEntry.lockedBalances]
               } serialized using userStoreSchema.
  ```

* For each entry `supplyEntry` in `genesisBlockAssetObject.supplySubstore`, create an entry in the supply substore with:
  ```python
  storeKey = uint32be(supplyEntry.localID)
  storeValue = {"totalSupply": supplyEntry.totalSupply} serialized using supplyStoreSchema.
  ```

* For each entry `escrowEntry` in `genesisBlockAssetObject.escrowSubstore`, create an entry in the escrow substore with:
  ```python
  storeKey = uint32be(escrowEntry.escrowChainID) || uint32be(escrowEntry.localID)
  storeValue = {"amount": escrowEntry.amount} serialized using escrowStoreSchema.
  ```

* Create an entry in the available local ID substore with:
  ```python
  storeKey = EMPTY_BYTES
  storeValue = {"nextAvailableLocalID": genesisBlockAssetObject.availableLocalIDSubstore.nextAvailableLocalID}
               serialized using availableLocalIDStoreSchema.
  ```

* For each entry `terminatedChainID` in `genesisBlockAssetObject.terminatedEscrowSubstore`, create an entry in the terminated escrow substore with:
  ```python
  storeKey = uint32be(terminatedChainID)
  storeValue = {"escrowTerminated": True} serialized using terminatedEscrowSchema.
  ```

Once the module store is initialized, its validity is attested via the two checks below.

* Check that for each native token the total supply is correct.
  This can be done by checking that the function below returns `True`.
  ```python
  validateSupplyStoreEntries():
      computedSupplies = {}
      for (storeKey, storeValue) in user substore:
          chainID = storeKey[20:24] # Part of the key corresponding to the chain ID of the token
          localID = storeKey[24:28] # Part of the key corresponding to the local ID of the token
          if chainID == CHAIN_ID_ALIAS_NATIVE:
              computedSupplies[localID] += sum of availableBalance and all locked amounts of storeValue

      for (storeKey, storeValue) in escrow substore:
          localID = storeKey[4:8] # Part of the key corresponding to the local ID of the token
          computedSupplies[localID] += storeValue.amount

      if computedSupplies[localID] >= 2^64 for any localID:
          return False

      storedSupplies = {}
      for (storeKey, storeValue) in supply substore:
          localID = storeKey
          storedSupplies[localID] = storeValue.amount

      # Check if both dictionary are coherent
      for localID in computedSupplies:
          if storedSupplies[localID] does not exist or computedSupplies[localID] != storedSupplies[localID]:
              return False

      for localID in storedSupplies:
          if computedSupplies[localID] does not exist and storedSupplies[localID] != 0:
              return False

      return True
  ```

* Check that for each native token the local ID is smaller than the recorded next available ID.
  This can be done by checking that the function below returns `True`.
  ```python
  nextAvailableLocalIDCorrect():
      maxLocalID = max storeKey of supply substore converted to integer, or -1 if the supply substore is empty
      nextLocalID = storeValue.nextAvailableLocalID of available local ID substore
      if maxLocalID < nextLocalID:
          return True
      else:
          return False
  ```

### Mainchain Minimum Balance Specifications

As specified in [LIP 0025](https://github.com/LiskHQ/lips/blob/main/proposals/lip-0025.md), mainchain user substore entries cannot hold less than `MIN_BALANCE` of LSK token. To follow this rule:

* Executing transactions that would result in an address `address` with `availableBalance(address, TOKEN_ID_LSK_MAINCHAIN) < MIN_BALANCE` is invalid. This is checked as part of the "after transaction execution" logic of the block lifecycle.
* Cross-chain messages that would result in an address `address` with `availableBalance(address, TOKEN_ID_LSK_MAINCHAIN) < MIN_BALANCE` after their execution must be rejected. This is done by calling `interoperability.error(ccm, CCM_STATUS_MIN_BALANCE_NOT_REACHED)` on the rejected message `ccm`.

### Protocol Logic for Other Modules

The Token module provides the following methods to modify the token state. Any other modules should use those to modify the token state. The token state should never be modified from outside the module without using one of the proposed functions as this could result in unexpected behavior and could cause an improper state transition.

In the following, we use the function:

```python
canonicalTokenID(tokenID):
    if tokenID.chainID == interoperability.getOwnChainAccount().ID
        return {"chainID": CHAIN_ID_ALIAS_NATIVE, "localID": tokenID.localID}
    else:
        return tokenID
```

This allows the functions below to be called with the chain ID of native tokens being either `CHAIN_ID_ALIAS_NATIVE` or the registered chain ID.

#### getAvailableBalance

```python
getAvailableBalance(address, tokenID):
    tokenID = canonicalTokenID(tokenID)
    return availableBalance(address, tokenID)
```

#### getLockedAmount

```python
getLockedAmount(address, moduleID, tokenID):
    tokenID = canonicalTokenID(tokenID)
    return lockedAmount(address, moduleID, tokenID)
```

#### getEscrowedAmount

```python
getEscrowedAmount(escrowChainID, tokenID):
    tokenID = canonicalTokenID(tokenID)
    if tokenID.chainID != CHAIN_ID_ALIAS_NATIVE:
        getEscrowedAmount fails
    return escrowAmount(escrowChainID, tokenID.localID)
```

#### getNextAvailableLocalID

```python
getNextAvailableLocalID():
    return nextAvailableLocalID
```

#### initializeToken

```python
initializeToken(localID):
    if supplyStore(localID) exists:
        initializeToken fails
    else:
        create a supply substore entry with
            storeKey = uint32be(localID)
            storeValue = {"totalsupply": 0} serialized using escrowStoreSchema

    if localID >= nextAvailableLocalID:
        nextAvailableLocalID = localID + 1
    return localID
```

#### mint

```python
mint(address, tokenID, amount):
    tokenID = canonicalTokenID(tokenID)
    # This function is only used to mint native tokens
    if (tokenID.chainID != CHAIN_ID_ALIAS_NATIVE
        or amount < 0
        or supplyStore(tokenID.localID) does not exist
        or availableBalance(address, tokenID) + amount >= 2^64):
        mint fails

    availableBalance(address, tokenID) += amount
    totalSupply(tokenID.localID) += amount
```

#### burn

```python
burn(address, tokenID, amount):
    tokenID = canonicalTokenID(tokenID)
    if (tokenID.chainID != CHAIN_ID_ALIAS_NATIVE
        or amount < 0
        or availableBalance(address, tokenID) < amount):
        burn fails

    availableBalance(address, tokenID) -= amount
    totalSupply(tokenID.localID) -= amount
```

#### transfer

```python
transfer(senderAddress, recipientAddress, tokenID, amount):
    tokenID = canonicalTokenID(tokenID)
    if (amount < 0:
        or availableBalance(senderAddress, tokenID) < amount):
        transfer fails

    availableBalance(senderAddress, tokenID) -= amount
    availableBalance(recipientAddress, tokenID) += amount
```

#### transferCrossChain

```python
transferCrossChain(senderAddress,
                   receivingChainID,
                   recipientAddress,
                   tokenID,
                   amount,
                   messageFee,
                   data):

    tokenID = canonicalTokenID(tokenID)
    chainID = tokenID.chainID
    localID = tokenID.localID

    # Basic formating checks
    if (amount < 0
        or length(data) > MAX_DATA_LENGTH
        or length(senderAddress) != ADDRESS_LENGTH
        or length(recipientAddress) != ADDRESS_LENGTH
        or availableBalance(senderAddress, tokenID) < amount):
        transferCrossChain fails

    # Transfer is only possible for tokens native to either sending or receiving chain
    # and if there is a direct channel, in which case a forward message will be sent
    if chainID not in [CHAIN_ID_ALIAS_NATIVE, receivingChainID, TOKEN_ID_LSK.chainID]:
        transferCrossChain fails

    if chainID == CHAIN_ID_ALIAS_NATIVE:  
        newTokenID = {"chainID": interoperability.getOwnChainAccount().ID,
                      "localID": localID}
    else:
        newTokenID = tokenID

    if chainID in [CHAIN_ID_ALIAS_NATIVE, receivingChainID]:
        messageParams = {  
            "tokenID": newTokenID,
            "amount": amount,
            "senderAddress": senderAddress,
            "recipientAddress": recipientAddress,
            "data": data
        }       
        serializedParams = serialization of messageParams
                           following crossChainTransferMessageParams    
        if interoperability.send(senderAddress,
                                 MODULE_ID_TOKEN,
                                 CROSS_CHAIN_COMMAND_ID_TRANSFER,
                                 receivingChainID,
                                 messageFee,
                                 CCM_STATUS_OK,
                                 serializedParams):
            availableBalance(senderAddress, tokenID) -= amount
            if chainID == CHAIN_ID_ALIAS_NATIVE:  
                escrowAmount(receivingChainID, localID) += amount

    else: # This case only happens for LSK tokens
        if availableBalance(senderAddress, tokenID) < (amount + messageFee):
            transferCrossChain fails

        messageParams = {  
            "tokenID": newTokenID,
            "amount": amount,
            "senderAddress": senderAddress,
            "forwardToChainID": receivingChainID,
            "recipientAddress": recipientAddress,
            "data": data,
            "forwardedMessageFee": messageFee
        }        
        serializedParams = serialization of messageParams
                           following crossChainForwardMessageParams
        if interoperability.send(senderAddress,
                                 MODULE_ID_TOKEN,
                                 CROSS_CHAIN_COMMAND_ID_FORWARD,
                                 chainID,
                                 0,
                                 CCM_STATUS_OK,
                                 serializedParams):
            availableBalance(senderAddress, tokenID) -= (amount + messageFee)
```

#### lock

```python
lock(address, moduleID, tokenID, amount):
    tokenID = canonicalTokenID(tokenID)
    if (amount < 0
        or availableBalance(address, tokenID) < amount):
        lock fails

    availableBalance(address, tokenID) -= amount
    lockedAmount(address, moduleID, tokenID) += amount
```

#### unlock

```python
unlock(address, moduleID, tokenID, amount):
    tokenID = canonicalTokenID(tokenID)
    if (amount < 0
        or lockedAmount(address, moduleID, tokenID) < amount):
        unlock fails

    lockedAmount(address, moduleID, tokenID) -= amount
    availableBalance(address, tokenID) += amount
```

#### forwardMessageFee

This function is only called during the execution of a cross-chain update on the mainchain.

```python
forwardMessageFee(ccm):
    fee = ccm.fee
    feeTokenID = interoperability.getChannel(ccm.sendingChainID).messageFeeTokenID
    if (fee < 0
        or feeTokenID != interoperability.getChannel(ccm.receivingChainID).messageFeeTokenID):
        forwardMessageFee fails


    if (feeTokenID.chainID != interoperability.getOwnChainAccount().ID
        or escrowAmount(ccm.sendingChainID, feeTokenID.localID) < fee):
        interoperability.terminateChain(ccm.sendingChainID)
        return False

    # Transfer the fee from escrow to escrow
    escrowAmount(ccm.sendingChainID, feeTokenID.localID) -= fee
    escrowAmount(ccm.receivingChainID, feeTokenID.localID) += fee
```

#### beforeApplyCCM

```python
beforeApplyCCM(ccu, ccm):
    relayerAddress = address derived from ccu.senderPublicKey
    fee = ccm.fee
    if fee < 0:
        beforeApplyCCM fails

    feeTokenID = interoperability.getChannel(ccm.sendingChainID).messageFeeTokenID
    # If the chain is the fee token native chain, unescrow and assign fee to relayer
    if feeTokenID.chainID == interoperability.getOwnChainAccount().ID:
        if escrowAmount(ccm.sendingChainID, feeTokenID.localID) < fee:
            interoperability.terminateChain(ccm.sendingChainID)
            return False

        escrowAmount(ccm.sendingChainID, feeTokenID.localID) -= fee
        availableBalance(relayerAddress, canonicalTokenID(feeTokenID)) += fee
    # Else, just assign the fee to relayer
    else:
        availableBalance(relayerAddress, feeTokenID) += fee    
```

#### beforeRecoverCCM

```python
beforeRecoverCCM(trsSender, ccm):
    fee = ccm.fee
    if fee < 0:
        beforeRecoverCCM fails

    feeTokenID = interoperability.getChannel(ccm.sendingChainID).messageFeeTokenID
    # If the chain is the fee token native chain, unescrow and assign fee to relayer
    if feeTokenID.chainID == interoperability.getOwnChainAccount().ID:
        if escrowAmount(ccm.sendingChainID, feeTokenID.localID) < fee:
            interoperability.terminateChain(ccm.sendingChainID)
            return False

        escrowAmount(ccm.sendingChainID, feeTokenID.localID) -= fee
        availableBalance(trsSender, canonicalTokenID(feeTokenID)) += fee
    # Else, just assign the fee to relayer
    else:
        availableBalance(relayerAddress, feeTokenID) += fee    
```

#### beforeSendCCM

```python
beforeSendCCM(payFromAddress, ccm):
    fee = ccm.fee
    if fee < 0:
        beforeSendCCM fails

    feeTokenID = interoperability.getChannel(ccm.receivingChainID).messageFeeTokenID
    # If the chain is the fee token native chain, escrow and pay fee
    if feeTokenID.chainID == interoperability.getOwnChainAccount().ID:
        if availableBalance(payFromAddress, canonicalTokenID(feeTokenID)) < fee:
            beforeSendCCM fails
        availableBalance(payFromAddress, canonicalTokenID(feeTokenID)) -= fee
        escrowAmount(ccm.receivingChainID, feeTokenID.localID) += fee
    # Else, pay fee
    else:
        if availableBalance(payFromAddress, feeTokenID) < fee:
            beforeSendCCM fails
        availableBalance(payFromAddress, feeTokenID) -= fee
```

#### recover

```python
recover(terminatedChainID, moduleID, storePrefix, storeKey, storeValue):
    if (storePrefix != STORE_PREFIX_USER
        or len(storeKey) != 28
        or storeValue cannot be deserialized using userStoreSchema):
        recover fails

    address = first ADDRESS_LENGTH bytes of storeKey
    chainID = bytes 21 to 24 of storeKey
    localID = last 4 bytes of storeKey
    account = storeValue deserialized using userStoreSchema
    totalAmount = sum of availableBalance and all locked amounts of account

    if (chainID != interoperability.getOwnChainAccount().ID
        or escrowAmount(terminatedChainID, localID) < totalAmount):
        recover fails

    escrowAmount(terminatedChainID, localID) -= totalAmount
    availableBalance(address, {"chainID":CHAIN_ID_ALIAS_NATIVE, "localID": localID}) += totalAmount
```

### Endpoints for Off-Chain Services

TBA

## Backwards Compatibility

This introduces a different token handling mechanism for the whole Lisk ecosystem which requires a hard fork.

## Reference Implementation

TBA

[research:base-interoperability]: https://research.lisk.com/t/introduce-interoperability-module/290
[research:ccm]: https://research.lisk.com/t/cross-chain-messages/299
[research:ccu]: https://research.lisk.com/t/introduce-cross-chain-update-transactions/298
[research:chain-registration]: https://research.lisk.com/t/chain-registration/291
[research:sidechain-recovery]: https://research.lisk.com/t/sidechain-recovery-transactions/292
